//This Code is auto generated by graphql-codegen, DO NOT EDIT
//You can update the queries or mutations in *.graphql to generate any new changes.
import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from 'react-query';
import { useFetchData } from './fetcher';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: any;
  JWT: any;
};

export type AccountLicense = {
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  licenseId: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  user?: Maybe<User>;
  userId: Scalars['String'];
};

export type AccountLicenseCreateNestedOneWithoutUserInput = {
  connect?: InputMaybe<AccountLicenseWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountLicenseCreateOrConnectWithoutUserInput>;
  create?: InputMaybe<AccountLicenseCreateWithoutUserInput>;
};

export type AccountLicenseCreateOrConnectWithoutUserInput = {
  create: AccountLicenseCreateWithoutUserInput;
  where: AccountLicenseWhereUniqueInput;
};

export type AccountLicenseCreateWithoutUserInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  licenseId: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type AccountLicenseOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  licenseId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationInput>;
  userId?: InputMaybe<SortOrder>;
};

export type AccountLicenseUpdateOneWithoutUserNestedInput = {
  connect?: InputMaybe<AccountLicenseWhereUniqueInput>;
  connectOrCreate?: InputMaybe<AccountLicenseCreateOrConnectWithoutUserInput>;
  create?: InputMaybe<AccountLicenseCreateWithoutUserInput>;
  delete?: InputMaybe<Scalars['Boolean']>;
  disconnect?: InputMaybe<Scalars['Boolean']>;
  update?: InputMaybe<AccountLicenseUpdateWithoutUserInput>;
  upsert?: InputMaybe<AccountLicenseUpsertWithoutUserInput>;
};

export type AccountLicenseUpdateWithoutUserInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  licenseId?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type AccountLicenseUpsertWithoutUserInput = {
  create: AccountLicenseCreateWithoutUserInput;
  update: AccountLicenseUpdateWithoutUserInput;
};

export type AccountLicenseWhereInput = {
  AND?: InputMaybe<Array<AccountLicenseWhereInput>>;
  NOT?: InputMaybe<Array<AccountLicenseWhereInput>>;
  OR?: InputMaybe<Array<AccountLicenseWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  licenseId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<StringFilter>;
};

export type AccountLicenseWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  licenseId?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['String']>;
};

export type Auth = {
  /** JWT access token */
  accessToken: Scalars['JWT'];
  /** JWT refresh token */
  refreshToken: Scalars['JWT'];
  user: User;
};

export type BoolFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['Boolean']>;
};

export type BoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type Category = {
  _count: CategoryCount;
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  products?: Maybe<Array<ProductCategory>>;
  updatedAt: Scalars['DateTime'];
};

export type CategoryConnection = {
  nodes?: Maybe<Array<Category>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type CategoryCount = {
  products: Scalars['Int'];
};

export type CategoryCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  products?: InputMaybe<ProductCategoryCreateNestedManyWithoutCategoryInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CategoryCreateNestedOneWithoutProductsInput = {
  connect?: InputMaybe<CategoryWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CategoryCreateOrConnectWithoutProductsInput>;
  create?: InputMaybe<CategoryCreateWithoutProductsInput>;
};

export type CategoryCreateOrConnectWithoutProductsInput = {
  create: CategoryCreateWithoutProductsInput;
  where: CategoryWhereUniqueInput;
};

export type CategoryCreateWithoutProductsInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CategoryOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  products?: InputMaybe<ProductCategoryOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum CategoryScalarFieldEnum {
  CreatedAt = 'createdAt',
  Id = 'id',
  Name = 'name',
  UpdatedAt = 'updatedAt'
}

export type CategoryUpdateInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  products?: InputMaybe<ProductCategoryUpdateManyWithoutCategoryNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
  connect?: InputMaybe<CategoryWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CategoryCreateOrConnectWithoutProductsInput>;
  create?: InputMaybe<CategoryCreateWithoutProductsInput>;
  update?: InputMaybe<CategoryUpdateWithoutProductsInput>;
  upsert?: InputMaybe<CategoryUpsertWithoutProductsInput>;
};

export type CategoryUpdateWithoutProductsInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type CategoryUpsertWithoutProductsInput = {
  create: CategoryCreateWithoutProductsInput;
  update: CategoryUpdateWithoutProductsInput;
};

export type CategoryWhereInput = {
  AND?: InputMaybe<Array<CategoryWhereInput>>;
  NOT?: InputMaybe<Array<CategoryWhereInput>>;
  OR?: InputMaybe<Array<CategoryWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  products?: InputMaybe<ProductCategoryListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type CategoryWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
};

export type ChangePasswordInput = {
  newPassword: Scalars['String'];
  oldPassword: Scalars['String'];
};

export type CreatePostInput = {
  content: Scalars['String'];
  title: Scalars['String'];
};

export type DateTimeFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['DateTime']>;
};

export type DateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export enum Duration {
  Month = 'Month',
  Year = 'Year'
}

export type EnumDurationFieldUpdateOperationsInput = {
  set?: InputMaybe<Duration>;
};

export type EnumDurationFilter = {
  equals?: InputMaybe<Duration>;
  in?: InputMaybe<Array<Duration>>;
  not?: InputMaybe<NestedEnumDurationFilter>;
  notIn?: InputMaybe<Array<Duration>>;
};

export type EnumOrderStatusFilter = {
  equals?: InputMaybe<OrderStatus>;
  in?: InputMaybe<Array<OrderStatus>>;
  not?: InputMaybe<NestedEnumOrderStatusFilter>;
  notIn?: InputMaybe<Array<OrderStatus>>;
};

export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<SubscriptionStatus>;
};

export type EnumSubscriptionStatusFilter = {
  equals?: InputMaybe<SubscriptionStatus>;
  in?: InputMaybe<Array<SubscriptionStatus>>;
  not?: InputMaybe<NestedEnumSubscriptionStatusFilter>;
  notIn?: InputMaybe<Array<SubscriptionStatus>>;
};

export type FloatFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Float']>;
  divide?: InputMaybe<Scalars['Float']>;
  increment?: InputMaybe<Scalars['Float']>;
  multiply?: InputMaybe<Scalars['Float']>;
  set?: InputMaybe<Scalars['Float']>;
};

export type FloatFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type IntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Int']>;
  divide?: InputMaybe<Scalars['Int']>;
  increment?: InputMaybe<Scalars['Int']>;
  multiply?: InputMaybe<Scalars['Int']>;
  set?: InputMaybe<Scalars['Int']>;
};

export type IntFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type License = {
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  key: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type LicenseConnection = {
  nodes?: Maybe<Array<License>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type LicenseCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  key: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type LicenseOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum LicenseScalarFieldEnum {
  CreatedAt = 'createdAt',
  Id = 'id',
  Key = 'key',
  UpdatedAt = 'updatedAt'
}

export type LicenseUpdateInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  key?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type LicenseWhereInput = {
  AND?: InputMaybe<Array<LicenseWhereInput>>;
  NOT?: InputMaybe<Array<LicenseWhereInput>>;
  OR?: InputMaybe<Array<LicenseWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  key?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type LicenseWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  key?: InputMaybe<Scalars['String']>;
};

export type LoginInput = {
  password: Scalars['String'];
  username: Scalars['String'];
};

export type Mutation = {
  assignUser: Scalars['Boolean'];
  changePassword: User;
  createOneCategory: Category;
  createOneLicense: License;
  createOnePlan: Plan;
  createOneProduct: Product;
  createOneRole: Role;
  createOneSub: Sub;
  createOneSubHistory: SubHistory;
  createPost: Post;
  deAssignUser: Scalars['Boolean'];
  deleteOneCategory: Category;
  deleteOneLicense: License;
  deleteOnePlan: Plan;
  deleteOneRole: Role;
  deleteOneSub: Sub;
  deleteOneSubHistory: SubHistory;
  grantPermission: Scalars['Boolean'];
  grantPermissions: Scalars['Boolean'];
  login: Auth;
  refreshToken: Token;
  revokePermission: Scalars['Boolean'];
  signup: Auth;
  updateOneCategory: Category;
  updateOneLicense: License;
  updateOnePlan: Plan;
  updateOneRole: Role;
  updateOneSub: Sub;
  updateOneSubHistory: SubHistory;
  updateUser: User;
};


export type MutationAssignUserArgs = {
  rolename: Scalars['String'];
  username: Scalars['String'];
};


export type MutationChangePasswordArgs = {
  data: ChangePasswordInput;
};


export type MutationCreateOneCategoryArgs = {
  data: CategoryCreateInput;
};


export type MutationCreateOneLicenseArgs = {
  data: LicenseCreateInput;
};


export type MutationCreateOnePlanArgs = {
  data: PlanCreateInput;
};


export type MutationCreateOneProductArgs = {
  data: ProductCreateInput;
};


export type MutationCreateOneRoleArgs = {
  data: RoleCreateInput;
};


export type MutationCreateOneSubArgs = {
  data: SubCreateInput;
};


export type MutationCreateOneSubHistoryArgs = {
  data: SubHistoryCreateInput;
};


export type MutationCreatePostArgs = {
  data: CreatePostInput;
};


export type MutationDeAssignUserArgs = {
  rolename: Scalars['String'];
  username: Scalars['String'];
};


export type MutationDeleteOneCategoryArgs = {
  where: CategoryWhereUniqueInput;
};


export type MutationDeleteOneLicenseArgs = {
  where: LicenseWhereUniqueInput;
};


export type MutationDeleteOnePlanArgs = {
  where: PlanWhereUniqueInput;
};


export type MutationDeleteOneRoleArgs = {
  name: Scalars['String'];
};


export type MutationDeleteOneSubArgs = {
  where: SubWhereUniqueInput;
};


export type MutationDeleteOneSubHistoryArgs = {
  where: SubHistoryWhereUniqueInput;
};


export type MutationGrantPermissionArgs = {
  object: Scalars['String'];
  operation: Scalars['String'];
  role: Scalars['String'];
};


export type MutationGrantPermissionsArgs = {
  permissions: Array<PermissionInput>;
  role: Scalars['String'];
};


export type MutationLoginArgs = {
  data: LoginInput;
};


export type MutationRefreshTokenArgs = {
  token: Scalars['JWT'];
};


export type MutationRevokePermissionArgs = {
  object: Scalars['String'];
  operation: Scalars['String'];
  role: Scalars['String'];
};


export type MutationSignupArgs = {
  data: SignupInput;
};


export type MutationUpdateOneCategoryArgs = {
  data: CategoryUpdateInput;
  where: CategoryWhereUniqueInput;
};


export type MutationUpdateOneLicenseArgs = {
  data: LicenseUpdateInput;
  where: LicenseWhereUniqueInput;
};


export type MutationUpdateOnePlanArgs = {
  data: PlanUpdateInput;
  where: PlanWhereUniqueInput;
};


export type MutationUpdateOneRoleArgs = {
  data: RoleUpdateInput;
  where: RoleWhereUniqueInput;
};


export type MutationUpdateOneSubArgs = {
  data: SubUpdateInput;
  where: SubWhereUniqueInput;
};


export type MutationUpdateOneSubHistoryArgs = {
  data: SubHistoryUpdateInput;
  where: SubHistoryWhereUniqueInput;
};


export type MutationUpdateUserArgs = {
  data: UpdateUserInput;
};

export type NestedBoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type NestedDateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedEnumDurationFilter = {
  equals?: InputMaybe<Duration>;
  in?: InputMaybe<Array<Duration>>;
  not?: InputMaybe<NestedEnumDurationFilter>;
  notIn?: InputMaybe<Array<Duration>>;
};

export type NestedEnumOrderStatusFilter = {
  equals?: InputMaybe<OrderStatus>;
  in?: InputMaybe<Array<OrderStatus>>;
  not?: InputMaybe<NestedEnumOrderStatusFilter>;
  notIn?: InputMaybe<Array<OrderStatus>>;
};

export type NestedEnumSubscriptionStatusFilter = {
  equals?: InputMaybe<SubscriptionStatus>;
  in?: InputMaybe<Array<SubscriptionStatus>>;
  not?: InputMaybe<NestedEnumSubscriptionStatusFilter>;
  notIn?: InputMaybe<Array<SubscriptionStatus>>;
};

export type NestedFloatFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type NestedIntFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedStringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NullableStringFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['String']>;
};

export type Order = {
  _count: OrderCount;
  countryCode: Scalars['String'];
  couponId: Scalars['String'];
  createdAt: Scalars['DateTime'];
  delivered: Scalars['Boolean'];
  email: Scalars['String'];
  exchangeRate: Scalars['Int'];
  gateway: Scalars['String'];
  id: Scalars['ID'];
  ipAddress: Scalars['String'];
  orderItems?: Maybe<Array<OrderItem>>;
  productTitle: Scalars['String'];
  referral: Scalars['String'];
  riskLevel: Scalars['Int'];
  status: OrderStatus;
  updatedAt: Scalars['DateTime'];
  usdValue: Scalars['Int'];
  userAgent: Scalars['String'];
};

export type OrderConnection = {
  nodes?: Maybe<Array<Order>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type OrderCount = {
  orderItems: Scalars['Int'];
};

export type OrderItem = {
  createdAt: Scalars['DateTime'];
  currency: Scalars['String'];
  id: Scalars['ID'];
  order: Order;
  orderId: Scalars['String'];
  quantity: Scalars['Int'];
  updatedAt: Scalars['DateTime'];
  value: Scalars['Int'];
};

export type OrderItemListRelationFilter = {
  every?: InputMaybe<OrderItemWhereInput>;
  none?: InputMaybe<OrderItemWhereInput>;
  some?: InputMaybe<OrderItemWhereInput>;
};

export type OrderItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type OrderItemWhereInput = {
  AND?: InputMaybe<Array<OrderItemWhereInput>>;
  NOT?: InputMaybe<Array<OrderItemWhereInput>>;
  OR?: InputMaybe<Array<OrderItemWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  currency?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  order?: InputMaybe<OrderWhereInput>;
  orderId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  value?: InputMaybe<IntFilter>;
};

export type OrderOrderByWithRelationInput = {
  countryCode?: InputMaybe<SortOrder>;
  couponId?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  delivered?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  exchangeRate?: InputMaybe<SortOrder>;
  gateway?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  ipAddress?: InputMaybe<SortOrder>;
  orderItems?: InputMaybe<OrderItemOrderByRelationAggregateInput>;
  productTitle?: InputMaybe<SortOrder>;
  referral?: InputMaybe<SortOrder>;
  riskLevel?: InputMaybe<SortOrder>;
  status?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  usdValue?: InputMaybe<SortOrder>;
  userAgent?: InputMaybe<SortOrder>;
};

export enum OrderScalarFieldEnum {
  CountryCode = 'countryCode',
  CouponId = 'couponId',
  CreatedAt = 'createdAt',
  Delivered = 'delivered',
  Email = 'email',
  ExchangeRate = 'exchangeRate',
  Gateway = 'gateway',
  Id = 'id',
  IpAddress = 'ipAddress',
  ProductTitle = 'productTitle',
  Referral = 'referral',
  RiskLevel = 'riskLevel',
  Status = 'status',
  UpdatedAt = 'updatedAt',
  UsdValue = 'usdValue',
  UserAgent = 'userAgent'
}

export enum OrderStatus {
  AwaitingPaymentConfirmation = 'awaitingPaymentConfirmation',
  ChargeBack = 'chargeBack',
  HighRisk = 'highRisk',
  NotPaid = 'notPaid',
  PartiallyPaid = 'partiallyPaid',
  Pendding = 'pendding',
  Refunded = 'refunded',
  Successful = 'successful'
}

export type OrderWhereInput = {
  AND?: InputMaybe<Array<OrderWhereInput>>;
  NOT?: InputMaybe<Array<OrderWhereInput>>;
  OR?: InputMaybe<Array<OrderWhereInput>>;
  countryCode?: InputMaybe<StringFilter>;
  couponId?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  delivered?: InputMaybe<BoolFilter>;
  email?: InputMaybe<StringFilter>;
  exchangeRate?: InputMaybe<IntFilter>;
  gateway?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  ipAddress?: InputMaybe<StringFilter>;
  orderItems?: InputMaybe<OrderItemListRelationFilter>;
  productTitle?: InputMaybe<StringFilter>;
  referral?: InputMaybe<StringFilter>;
  riskLevel?: InputMaybe<IntFilter>;
  status?: InputMaybe<EnumOrderStatusFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  usdValue?: InputMaybe<IntFilter>;
  userAgent?: InputMaybe<StringFilter>;
};

export type OrderWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
};

export type PageInfo = {
  endCursor?: Maybe<Scalars['String']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['String']>;
};

export type PermissionInput = {
  object: Scalars['String'];
  operation: Scalars['String'];
};

export type Plan = {
  _count: PlanCount;
  createdAt: Scalars['DateTime'];
  duration: Duration;
  id: Scalars['ID'];
  name: Scalars['String'];
  price: Scalars['Float'];
  subscriptions?: Maybe<Array<Sub>>;
  updatedAt: Scalars['DateTime'];
};

export type PlanConnection = {
  nodes?: Maybe<Array<Plan>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type PlanCount = {
  subscriptions: Scalars['Int'];
};

export type PlanCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  duration: Duration;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  price: Scalars['Float'];
  subscriptions?: InputMaybe<SubCreateNestedManyWithoutPlanInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type PlanCreateNestedOneWithoutSubscriptionsInput = {
  connect?: InputMaybe<PlanWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlanCreateOrConnectWithoutSubscriptionsInput>;
  create?: InputMaybe<PlanCreateWithoutSubscriptionsInput>;
};

export type PlanCreateOrConnectWithoutSubscriptionsInput = {
  create: PlanCreateWithoutSubscriptionsInput;
  where: PlanWhereUniqueInput;
};

export type PlanCreateWithoutSubscriptionsInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  duration: Duration;
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  price: Scalars['Float'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type PlanOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  duration?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  price?: InputMaybe<SortOrder>;
  subscriptions?: InputMaybe<SubOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum PlanScalarFieldEnum {
  CreatedAt = 'createdAt',
  Duration = 'duration',
  Id = 'id',
  Name = 'name',
  Price = 'price',
  UpdatedAt = 'updatedAt'
}

export type PlanUpdateInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  duration?: InputMaybe<EnumDurationFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  subscriptions?: InputMaybe<SubUpdateManyWithoutPlanNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
  connect?: InputMaybe<PlanWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PlanCreateOrConnectWithoutSubscriptionsInput>;
  create?: InputMaybe<PlanCreateWithoutSubscriptionsInput>;
  update?: InputMaybe<PlanUpdateWithoutSubscriptionsInput>;
  upsert?: InputMaybe<PlanUpsertWithoutSubscriptionsInput>;
};

export type PlanUpdateWithoutSubscriptionsInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  duration?: InputMaybe<EnumDurationFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PlanUpsertWithoutSubscriptionsInput = {
  create: PlanCreateWithoutSubscriptionsInput;
  update: PlanUpdateWithoutSubscriptionsInput;
};

export type PlanWhereInput = {
  AND?: InputMaybe<Array<PlanWhereInput>>;
  NOT?: InputMaybe<Array<PlanWhereInput>>;
  OR?: InputMaybe<Array<PlanWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  duration?: InputMaybe<EnumDurationFilter>;
  id?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  price?: InputMaybe<FloatFilter>;
  subscriptions?: InputMaybe<SubListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PlanWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
};

export type Post = {
  author?: Maybe<User>;
  authorId?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  published: Scalars['Boolean'];
  title: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type PostConnection = {
  nodes?: Maybe<Array<Post>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type PostCreateManyAuthorInput = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  published: Scalars['Boolean'];
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type PostCreateManyAuthorInputEnvelope = {
  data: Array<PostCreateManyAuthorInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type PostCreateNestedManyWithoutAuthorInput = {
  connect?: InputMaybe<Array<PostWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PostCreateOrConnectWithoutAuthorInput>>;
  create?: InputMaybe<Array<PostCreateWithoutAuthorInput>>;
  createMany?: InputMaybe<PostCreateManyAuthorInputEnvelope>;
};

export type PostCreateOrConnectWithoutAuthorInput = {
  create: PostCreateWithoutAuthorInput;
  where: PostWhereUniqueInput;
};

export type PostCreateWithoutAuthorInput = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  published: Scalars['Boolean'];
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type PostListRelationFilter = {
  every?: InputMaybe<PostWhereInput>;
  none?: InputMaybe<PostWhereInput>;
  some?: InputMaybe<PostWhereInput>;
};

export type PostOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PostOrderByWithRelationInput = {
  author?: InputMaybe<UserOrderByWithRelationInput>;
  authorId?: InputMaybe<SortOrder>;
  content?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  published?: InputMaybe<SortOrder>;
  title?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum PostScalarFieldEnum {
  AuthorId = 'authorId',
  Content = 'content',
  CreatedAt = 'createdAt',
  Id = 'id',
  Published = 'published',
  Title = 'title',
  UpdatedAt = 'updatedAt'
}

export type PostScalarWhereInput = {
  AND?: InputMaybe<Array<PostScalarWhereInput>>;
  NOT?: InputMaybe<Array<PostScalarWhereInput>>;
  OR?: InputMaybe<Array<PostScalarWhereInput>>;
  authorId?: InputMaybe<StringNullableFilter>;
  content?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  published?: InputMaybe<BoolFilter>;
  title?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PostUpdateManyMutationInput = {
  content?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  published?: InputMaybe<BoolFieldUpdateOperationsInput>;
  title?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PostUpdateManyWithWhereWithoutAuthorInput = {
  data: PostUpdateManyMutationInput;
  where: PostScalarWhereInput;
};

export type PostUpdateManyWithoutAuthorNestedInput = {
  connect?: InputMaybe<Array<PostWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PostCreateOrConnectWithoutAuthorInput>>;
  create?: InputMaybe<Array<PostCreateWithoutAuthorInput>>;
  createMany?: InputMaybe<PostCreateManyAuthorInputEnvelope>;
  delete?: InputMaybe<Array<PostWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PostScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PostWhereUniqueInput>>;
  set?: InputMaybe<Array<PostWhereUniqueInput>>;
  update?: InputMaybe<Array<PostUpdateWithWhereUniqueWithoutAuthorInput>>;
  updateMany?: InputMaybe<Array<PostUpdateManyWithWhereWithoutAuthorInput>>;
  upsert?: InputMaybe<Array<PostUpsertWithWhereUniqueWithoutAuthorInput>>;
};

export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
  data: PostUpdateWithoutAuthorInput;
  where: PostWhereUniqueInput;
};

export type PostUpdateWithoutAuthorInput = {
  content?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  published?: InputMaybe<BoolFieldUpdateOperationsInput>;
  title?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
  create: PostCreateWithoutAuthorInput;
  update: PostUpdateWithoutAuthorInput;
  where: PostWhereUniqueInput;
};

export type PostWhereInput = {
  AND?: InputMaybe<Array<PostWhereInput>>;
  NOT?: InputMaybe<Array<PostWhereInput>>;
  OR?: InputMaybe<Array<PostWhereInput>>;
  author?: InputMaybe<UserWhereInput>;
  authorId?: InputMaybe<StringNullableFilter>;
  content?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  published?: InputMaybe<BoolFilter>;
  title?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PostWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
};

export type Product = {
  _count: ProductCount;
  categories?: Maybe<Array<ProductCategory>>;
  createdAt: Scalars['DateTime'];
  cryptoConfirmations: Scalars['Int'];
  currency: Scalars['String'];
  description: Scalars['String'];
  dynamicUrl: Scalars['String'];
  id: Scalars['ID'];
  info: Scalars['String'];
  maxRiskLevel: Scalars['Int'];
  maximumQuantity: Scalars['Int'];
  minimumQuantity: Scalars['Int'];
  private: Scalars['Boolean'];
  productType: Scalars['String'];
  seller_note: Scalars['String'];
  stock: Scalars['Int'];
  stockAmount: Scalars['Int'];
  stockDelimiter: Scalars['String'];
  title: Scalars['String'];
  unlisted: Scalars['Boolean'];
  updatedAt: Scalars['DateTime'];
  vpn_block: Scalars['Boolean'];
  webhookUrl: Scalars['String'];
};

export type ProductCategory = {
  category: Category;
  categoryId: Scalars['String'];
  product: Product;
  productId: Scalars['String'];
};

export type ProductCategoryCreateManyCategoryInput = {
  productId: Scalars['String'];
};

export type ProductCategoryCreateManyCategoryInputEnvelope = {
  data: Array<ProductCategoryCreateManyCategoryInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type ProductCategoryCreateManyProductInput = {
  categoryId: Scalars['String'];
};

export type ProductCategoryCreateManyProductInputEnvelope = {
  data: Array<ProductCategoryCreateManyProductInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type ProductCategoryCreateNestedManyWithoutCategoryInput = {
  connect?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductCategoryCreateOrConnectWithoutCategoryInput>>;
  create?: InputMaybe<Array<ProductCategoryCreateWithoutCategoryInput>>;
  createMany?: InputMaybe<ProductCategoryCreateManyCategoryInputEnvelope>;
};

export type ProductCategoryCreateNestedManyWithoutProductInput = {
  connect?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductCategoryCreateOrConnectWithoutProductInput>>;
  create?: InputMaybe<Array<ProductCategoryCreateWithoutProductInput>>;
  createMany?: InputMaybe<ProductCategoryCreateManyProductInputEnvelope>;
};

export type ProductCategoryCreateOrConnectWithoutCategoryInput = {
  create: ProductCategoryCreateWithoutCategoryInput;
  where: ProductCategoryWhereUniqueInput;
};

export type ProductCategoryCreateOrConnectWithoutProductInput = {
  create: ProductCategoryCreateWithoutProductInput;
  where: ProductCategoryWhereUniqueInput;
};

export type ProductCategoryCreateWithoutCategoryInput = {
  product: ProductCreateNestedOneWithoutCategoriesInput;
};

export type ProductCategoryCreateWithoutProductInput = {
  category: CategoryCreateNestedOneWithoutProductsInput;
};

export type ProductCategoryListRelationFilter = {
  every?: InputMaybe<ProductCategoryWhereInput>;
  none?: InputMaybe<ProductCategoryWhereInput>;
  some?: InputMaybe<ProductCategoryWhereInput>;
};

export type ProductCategoryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ProductCategoryProductIdCategoryIdCompoundUniqueInput = {
  categoryId: Scalars['String'];
  productId: Scalars['String'];
};

export type ProductCategoryScalarWhereInput = {
  AND?: InputMaybe<Array<ProductCategoryScalarWhereInput>>;
  NOT?: InputMaybe<Array<ProductCategoryScalarWhereInput>>;
  OR?: InputMaybe<Array<ProductCategoryScalarWhereInput>>;
  categoryId?: InputMaybe<StringFilter>;
  productId?: InputMaybe<StringFilter>;
};

export type ProductCategoryUncheckedUpdateManyWithoutCategoriesInput = {
  categoryId?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ProductCategoryUncheckedUpdateManyWithoutProductsInput = {
  productId?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ProductCategoryUpdateManyWithWhereWithoutCategoryInput = {
  data: ProductCategoryUncheckedUpdateManyWithoutProductsInput;
  where: ProductCategoryScalarWhereInput;
};

export type ProductCategoryUpdateManyWithWhereWithoutProductInput = {
  data: ProductCategoryUncheckedUpdateManyWithoutCategoriesInput;
  where: ProductCategoryScalarWhereInput;
};

export type ProductCategoryUpdateManyWithoutCategoryNestedInput = {
  connect?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductCategoryCreateOrConnectWithoutCategoryInput>>;
  create?: InputMaybe<Array<ProductCategoryCreateWithoutCategoryInput>>;
  createMany?: InputMaybe<ProductCategoryCreateManyCategoryInputEnvelope>;
  delete?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ProductCategoryScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  set?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  update?: InputMaybe<Array<ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput>>;
  updateMany?: InputMaybe<Array<ProductCategoryUpdateManyWithWhereWithoutCategoryInput>>;
  upsert?: InputMaybe<Array<ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput>>;
};

export type ProductCategoryUpdateManyWithoutProductNestedInput = {
  connect?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductCategoryCreateOrConnectWithoutProductInput>>;
  create?: InputMaybe<Array<ProductCategoryCreateWithoutProductInput>>;
  createMany?: InputMaybe<ProductCategoryCreateManyProductInputEnvelope>;
  delete?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ProductCategoryScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  set?: InputMaybe<Array<ProductCategoryWhereUniqueInput>>;
  update?: InputMaybe<Array<ProductCategoryUpdateWithWhereUniqueWithoutProductInput>>;
  updateMany?: InputMaybe<Array<ProductCategoryUpdateManyWithWhereWithoutProductInput>>;
  upsert?: InputMaybe<Array<ProductCategoryUpsertWithWhereUniqueWithoutProductInput>>;
};

export type ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
  data: ProductCategoryUpdateWithoutCategoryInput;
  where: ProductCategoryWhereUniqueInput;
};

export type ProductCategoryUpdateWithWhereUniqueWithoutProductInput = {
  data: ProductCategoryUpdateWithoutProductInput;
  where: ProductCategoryWhereUniqueInput;
};

export type ProductCategoryUpdateWithoutCategoryInput = {
  product?: InputMaybe<ProductUpdateOneRequiredWithoutCategoriesNestedInput>;
};

export type ProductCategoryUpdateWithoutProductInput = {
  category?: InputMaybe<CategoryUpdateOneRequiredWithoutProductsNestedInput>;
};

export type ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
  create: ProductCategoryCreateWithoutCategoryInput;
  update: ProductCategoryUpdateWithoutCategoryInput;
  where: ProductCategoryWhereUniqueInput;
};

export type ProductCategoryUpsertWithWhereUniqueWithoutProductInput = {
  create: ProductCategoryCreateWithoutProductInput;
  update: ProductCategoryUpdateWithoutProductInput;
  where: ProductCategoryWhereUniqueInput;
};

export type ProductCategoryWhereInput = {
  AND?: InputMaybe<Array<ProductCategoryWhereInput>>;
  NOT?: InputMaybe<Array<ProductCategoryWhereInput>>;
  OR?: InputMaybe<Array<ProductCategoryWhereInput>>;
  category?: InputMaybe<CategoryWhereInput>;
  categoryId?: InputMaybe<StringFilter>;
  product?: InputMaybe<ProductWhereInput>;
  productId?: InputMaybe<StringFilter>;
};

export type ProductCategoryWhereUniqueInput = {
  productId_categoryId?: InputMaybe<ProductCategoryProductIdCategoryIdCompoundUniqueInput>;
};

export type ProductConnection = {
  nodes?: Maybe<Array<Product>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ProductCount = {
  categories: Scalars['Int'];
};

export type ProductCreateInput = {
  categories?: InputMaybe<ProductCategoryCreateNestedManyWithoutProductInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  cryptoConfirmations: Scalars['Int'];
  currency: Scalars['String'];
  description: Scalars['String'];
  dynamicUrl: Scalars['String'];
  id?: InputMaybe<Scalars['String']>;
  info: Scalars['String'];
  maxRiskLevel: Scalars['Int'];
  maximumQuantity: Scalars['Int'];
  minimumQuantity: Scalars['Int'];
  private: Scalars['Boolean'];
  productType: Scalars['String'];
  seller_note: Scalars['String'];
  stock: Scalars['Int'];
  stockAmount: Scalars['Int'];
  stockDelimiter: Scalars['String'];
  title: Scalars['String'];
  unlisted: Scalars['Boolean'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  vpn_block: Scalars['Boolean'];
  webhookUrl: Scalars['String'];
};

export type ProductCreateNestedOneWithoutCategoriesInput = {
  connect?: InputMaybe<ProductWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductCreateOrConnectWithoutCategoriesInput>;
  create?: InputMaybe<ProductCreateWithoutCategoriesInput>;
};

export type ProductCreateOrConnectWithoutCategoriesInput = {
  create: ProductCreateWithoutCategoriesInput;
  where: ProductWhereUniqueInput;
};

export type ProductCreateWithoutCategoriesInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  cryptoConfirmations: Scalars['Int'];
  currency: Scalars['String'];
  description: Scalars['String'];
  dynamicUrl: Scalars['String'];
  id?: InputMaybe<Scalars['String']>;
  info: Scalars['String'];
  maxRiskLevel: Scalars['Int'];
  maximumQuantity: Scalars['Int'];
  minimumQuantity: Scalars['Int'];
  private: Scalars['Boolean'];
  productType: Scalars['String'];
  seller_note: Scalars['String'];
  stock: Scalars['Int'];
  stockAmount: Scalars['Int'];
  stockDelimiter: Scalars['String'];
  title: Scalars['String'];
  unlisted: Scalars['Boolean'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  vpn_block: Scalars['Boolean'];
  webhookUrl: Scalars['String'];
};

export type ProductOrderByWithRelationInput = {
  categories?: InputMaybe<ProductCategoryOrderByRelationAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  cryptoConfirmations?: InputMaybe<SortOrder>;
  currency?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  dynamicUrl?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  info?: InputMaybe<SortOrder>;
  maxRiskLevel?: InputMaybe<SortOrder>;
  maximumQuantity?: InputMaybe<SortOrder>;
  minimumQuantity?: InputMaybe<SortOrder>;
  private?: InputMaybe<SortOrder>;
  productType?: InputMaybe<SortOrder>;
  seller_note?: InputMaybe<SortOrder>;
  stock?: InputMaybe<SortOrder>;
  stockAmount?: InputMaybe<SortOrder>;
  stockDelimiter?: InputMaybe<SortOrder>;
  title?: InputMaybe<SortOrder>;
  unlisted?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  vpn_block?: InputMaybe<SortOrder>;
  webhookUrl?: InputMaybe<SortOrder>;
};

export enum ProductScalarFieldEnum {
  CreatedAt = 'createdAt',
  CryptoConfirmations = 'cryptoConfirmations',
  Currency = 'currency',
  Description = 'description',
  DynamicUrl = 'dynamicUrl',
  Id = 'id',
  Info = 'info',
  MaxRiskLevel = 'maxRiskLevel',
  MaximumQuantity = 'maximumQuantity',
  MinimumQuantity = 'minimumQuantity',
  Private = 'private',
  ProductType = 'productType',
  SellerNote = 'seller_note',
  Stock = 'stock',
  StockAmount = 'stockAmount',
  StockDelimiter = 'stockDelimiter',
  Title = 'title',
  Unlisted = 'unlisted',
  UpdatedAt = 'updatedAt',
  VpnBlock = 'vpn_block',
  WebhookUrl = 'webhookUrl'
}

export type ProductUpdateInput = {
  categories?: InputMaybe<ProductCategoryUpdateManyWithoutProductNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  cryptoConfirmations?: InputMaybe<IntFieldUpdateOperationsInput>;
  currency?: InputMaybe<StringFieldUpdateOperationsInput>;
  description?: InputMaybe<StringFieldUpdateOperationsInput>;
  dynamicUrl?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  info?: InputMaybe<StringFieldUpdateOperationsInput>;
  maxRiskLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  maximumQuantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  minimumQuantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  private?: InputMaybe<BoolFieldUpdateOperationsInput>;
  productType?: InputMaybe<StringFieldUpdateOperationsInput>;
  seller_note?: InputMaybe<StringFieldUpdateOperationsInput>;
  stock?: InputMaybe<IntFieldUpdateOperationsInput>;
  stockAmount?: InputMaybe<IntFieldUpdateOperationsInput>;
  stockDelimiter?: InputMaybe<StringFieldUpdateOperationsInput>;
  title?: InputMaybe<StringFieldUpdateOperationsInput>;
  unlisted?: InputMaybe<BoolFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  vpn_block?: InputMaybe<BoolFieldUpdateOperationsInput>;
  webhookUrl?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ProductUpdateOneRequiredWithoutCategoriesNestedInput = {
  connect?: InputMaybe<ProductWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductCreateOrConnectWithoutCategoriesInput>;
  create?: InputMaybe<ProductCreateWithoutCategoriesInput>;
  update?: InputMaybe<ProductUpdateWithoutCategoriesInput>;
  upsert?: InputMaybe<ProductUpsertWithoutCategoriesInput>;
};

export type ProductUpdateWithoutCategoriesInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  cryptoConfirmations?: InputMaybe<IntFieldUpdateOperationsInput>;
  currency?: InputMaybe<StringFieldUpdateOperationsInput>;
  description?: InputMaybe<StringFieldUpdateOperationsInput>;
  dynamicUrl?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  info?: InputMaybe<StringFieldUpdateOperationsInput>;
  maxRiskLevel?: InputMaybe<IntFieldUpdateOperationsInput>;
  maximumQuantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  minimumQuantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  private?: InputMaybe<BoolFieldUpdateOperationsInput>;
  productType?: InputMaybe<StringFieldUpdateOperationsInput>;
  seller_note?: InputMaybe<StringFieldUpdateOperationsInput>;
  stock?: InputMaybe<IntFieldUpdateOperationsInput>;
  stockAmount?: InputMaybe<IntFieldUpdateOperationsInput>;
  stockDelimiter?: InputMaybe<StringFieldUpdateOperationsInput>;
  title?: InputMaybe<StringFieldUpdateOperationsInput>;
  unlisted?: InputMaybe<BoolFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  vpn_block?: InputMaybe<BoolFieldUpdateOperationsInput>;
  webhookUrl?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ProductUpsertWithoutCategoriesInput = {
  create: ProductCreateWithoutCategoriesInput;
  update: ProductUpdateWithoutCategoriesInput;
};

export type ProductWhereInput = {
  AND?: InputMaybe<Array<ProductWhereInput>>;
  NOT?: InputMaybe<Array<ProductWhereInput>>;
  OR?: InputMaybe<Array<ProductWhereInput>>;
  categories?: InputMaybe<ProductCategoryListRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  cryptoConfirmations?: InputMaybe<IntFilter>;
  currency?: InputMaybe<StringFilter>;
  description?: InputMaybe<StringFilter>;
  dynamicUrl?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  info?: InputMaybe<StringFilter>;
  maxRiskLevel?: InputMaybe<IntFilter>;
  maximumQuantity?: InputMaybe<IntFilter>;
  minimumQuantity?: InputMaybe<IntFilter>;
  private?: InputMaybe<BoolFilter>;
  productType?: InputMaybe<StringFilter>;
  seller_note?: InputMaybe<StringFilter>;
  stock?: InputMaybe<IntFilter>;
  stockAmount?: InputMaybe<IntFilter>;
  stockDelimiter?: InputMaybe<StringFilter>;
  title?: InputMaybe<StringFilter>;
  unlisted?: InputMaybe<BoolFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  vpn_block?: InputMaybe<BoolFilter>;
  webhookUrl?: InputMaybe<StringFilter>;
};

export type ProductWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
};

export type Query = {
  categories: CategoryConnection;
  category: Category;
  deleteOneProduct: Product;
  getRolePermissions: Array<Array<Scalars['String']>>;
  getUserPermissions: Array<Array<Scalars['String']>>;
  getUserRoles: Array<Scalars['String']>;
  license: License;
  licenses: LicenseConnection;
  me: User;
  orders: OrderConnection;
  plan: Plan;
  plans: PlanConnection;
  post: Post;
  posts: PostConnection;
  product: Product;
  products: ProductConnection;
  role: Role;
  roles: RoleConnection;
  sub: Sub;
  subHistories: SubHistoryConnection;
  subHistory: SubHistory;
  subs: SubConnection;
  updateOneProduct: Product;
  userPosts: Array<Post>;
  users: UserConnection;
};


export type QueryCategoriesArgs = {
  cursor?: InputMaybe<CategoryWhereUniqueInput>;
  distinct?: InputMaybe<Array<CategoryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<CategoryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CategoryWhereInput>;
};


export type QueryCategoryArgs = {
  cursor?: InputMaybe<CategoryWhereUniqueInput>;
  distinct?: InputMaybe<Array<CategoryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<CategoryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CategoryWhereInput>;
};


export type QueryDeleteOneProductArgs = {
  where: ProductWhereUniqueInput;
};


export type QueryGetRolePermissionsArgs = {
  rolename: Scalars['String'];
};


export type QueryGetUserPermissionsArgs = {
  username: Scalars['String'];
};


export type QueryGetUserRolesArgs = {
  username: Scalars['String'];
};


export type QueryLicenseArgs = {
  cursor?: InputMaybe<LicenseWhereUniqueInput>;
  distinct?: InputMaybe<Array<LicenseScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<LicenseOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LicenseWhereInput>;
};


export type QueryLicensesArgs = {
  cursor?: InputMaybe<LicenseWhereUniqueInput>;
  distinct?: InputMaybe<Array<LicenseScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<LicenseOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LicenseWhereInput>;
};


export type QueryOrdersArgs = {
  cursor?: InputMaybe<OrderWhereUniqueInput>;
  distinct?: InputMaybe<Array<OrderScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<OrderOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<OrderWhereInput>;
};


export type QueryPlanArgs = {
  where: PlanWhereUniqueInput;
};


export type QueryPlansArgs = {
  cursor?: InputMaybe<PlanWhereUniqueInput>;
  distinct?: InputMaybe<Array<PlanScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PlanOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PlanWhereInput>;
};


export type QueryPostArgs = {
  postId: Scalars['String'];
};


export type QueryPostsArgs = {
  cursor?: InputMaybe<PostWhereUniqueInput>;
  distinct?: InputMaybe<Array<PostScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<PostOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PostWhereInput>;
};


export type QueryProductArgs = {
  cursor?: InputMaybe<ProductWhereUniqueInput>;
  distinct?: InputMaybe<Array<ProductScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ProductOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProductWhereInput>;
};


export type QueryProductsArgs = {
  cursor?: InputMaybe<ProductWhereUniqueInput>;
  distinct?: InputMaybe<Array<ProductScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ProductOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProductWhereInput>;
};


export type QueryRoleArgs = {
  where: RoleWhereUniqueInput;
};


export type QueryRolesArgs = {
  cursor?: InputMaybe<RoleWhereUniqueInput>;
  distinct?: InputMaybe<Array<RoleScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<RoleOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RoleWhereInput>;
};


export type QuerySubArgs = {
  where: SubWhereUniqueInput;
};


export type QuerySubHistoriesArgs = {
  cursor?: InputMaybe<SubHistoryWhereUniqueInput>;
  distinct?: InputMaybe<Array<SubHistoryScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SubHistoryOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SubHistoryWhereInput>;
};


export type QuerySubHistoryArgs = {
  where: SubHistoryWhereUniqueInput;
};


export type QuerySubsArgs = {
  cursor?: InputMaybe<SubWhereUniqueInput>;
  distinct?: InputMaybe<Array<SubScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SubOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SubWhereInput>;
};


export type QueryUpdateOneProductArgs = {
  data: ProductUpdateInput;
  where: ProductWhereUniqueInput;
};


export type QueryUserPostsArgs = {
  userId: Scalars['String'];
};


export type QueryUsersArgs = {
  cursor?: InputMaybe<UserWhereUniqueInput>;
  distinct?: InputMaybe<Array<UserScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserWhereInput>;
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type Role = {
  createdAt: Scalars['DateTime'];
  description: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type RoleConnection = {
  nodes?: Maybe<Array<Role>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type RoleCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  description: Scalars['String'];
  id?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type RoleOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum RoleScalarFieldEnum {
  CreatedAt = 'createdAt',
  Description = 'description',
  Id = 'id',
  Name = 'name',
  UpdatedAt = 'updatedAt'
}

export type RoleUpdateInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  description?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type RoleWhereInput = {
  AND?: InputMaybe<Array<RoleWhereInput>>;
  NOT?: InputMaybe<Array<RoleWhereInput>>;
  OR?: InputMaybe<Array<RoleWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  description?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type RoleWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

export type SignupInput = {
  firstname?: InputMaybe<Scalars['String']>;
  lastname?: InputMaybe<Scalars['String']>;
  password: Scalars['String'];
  username: Scalars['String'];
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StringFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['String']>;
};

export type StringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type Sub = {
  _count: SubCount;
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  plan: Plan;
  planId: Scalars['String'];
  status: SubscriptionStatus;
  subHistories?: Maybe<Array<SubHistory>>;
  updatedAt: Scalars['DateTime'];
  user: User;
  userId: Scalars['String'];
};

export type SubConnection = {
  nodes?: Maybe<Array<Sub>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type SubCount = {
  subHistories: Scalars['Int'];
};

export type SubCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  plan: PlanCreateNestedOneWithoutSubscriptionsInput;
  status: SubscriptionStatus;
  subHistories?: InputMaybe<SubHistoryCreateNestedManyWithoutSubInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  user: UserCreateNestedOneWithoutSubscriptionsInput;
};

export type SubCreateManyPlanInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  status: SubscriptionStatus;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  userId: Scalars['String'];
};

export type SubCreateManyPlanInputEnvelope = {
  data: Array<SubCreateManyPlanInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type SubCreateNestedManyWithoutPlanInput = {
  connect?: InputMaybe<Array<SubWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SubCreateOrConnectWithoutPlanInput>>;
  create?: InputMaybe<Array<SubCreateWithoutPlanInput>>;
  createMany?: InputMaybe<SubCreateManyPlanInputEnvelope>;
};

export type SubCreateNestedOneWithoutSubHistoriesInput = {
  connect?: InputMaybe<SubWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SubCreateOrConnectWithoutSubHistoriesInput>;
  create?: InputMaybe<SubCreateWithoutSubHistoriesInput>;
};

export type SubCreateOrConnectWithoutPlanInput = {
  create: SubCreateWithoutPlanInput;
  where: SubWhereUniqueInput;
};

export type SubCreateOrConnectWithoutSubHistoriesInput = {
  create: SubCreateWithoutSubHistoriesInput;
  where: SubWhereUniqueInput;
};

export type SubCreateWithoutPlanInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  status: SubscriptionStatus;
  subHistories?: InputMaybe<SubHistoryCreateNestedManyWithoutSubInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  user: UserCreateNestedOneWithoutSubscriptionsInput;
};

export type SubCreateWithoutSubHistoriesInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  id?: InputMaybe<Scalars['String']>;
  plan: PlanCreateNestedOneWithoutSubscriptionsInput;
  status: SubscriptionStatus;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  user: UserCreateNestedOneWithoutSubscriptionsInput;
};

export type SubHistory = {
  createdAt: Scalars['DateTime'];
  expiredAt: Scalars['DateTime'];
  id: Scalars['ID'];
  startAt: Scalars['DateTime'];
  sub: Sub;
  subId: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type SubHistoryConnection = {
  nodes?: Maybe<Array<SubHistory>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type SubHistoryCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  expiredAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['String']>;
  startAt: Scalars['DateTime'];
  sub: SubCreateNestedOneWithoutSubHistoriesInput;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type SubHistoryCreateManySubInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  expiredAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['String']>;
  startAt: Scalars['DateTime'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type SubHistoryCreateManySubInputEnvelope = {
  data: Array<SubHistoryCreateManySubInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']>;
};

export type SubHistoryCreateNestedManyWithoutSubInput = {
  connect?: InputMaybe<Array<SubHistoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SubHistoryCreateOrConnectWithoutSubInput>>;
  create?: InputMaybe<Array<SubHistoryCreateWithoutSubInput>>;
  createMany?: InputMaybe<SubHistoryCreateManySubInputEnvelope>;
};

export type SubHistoryCreateOrConnectWithoutSubInput = {
  create: SubHistoryCreateWithoutSubInput;
  where: SubHistoryWhereUniqueInput;
};

export type SubHistoryCreateWithoutSubInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  expiredAt: Scalars['DateTime'];
  id?: InputMaybe<Scalars['String']>;
  startAt: Scalars['DateTime'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type SubHistoryListRelationFilter = {
  every?: InputMaybe<SubHistoryWhereInput>;
  none?: InputMaybe<SubHistoryWhereInput>;
  some?: InputMaybe<SubHistoryWhereInput>;
};

export type SubHistoryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SubHistoryOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  expiredAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  startAt?: InputMaybe<SortOrder>;
  sub?: InputMaybe<SubOrderByWithRelationInput>;
  subId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum SubHistoryScalarFieldEnum {
  CreatedAt = 'createdAt',
  ExpiredAt = 'expiredAt',
  Id = 'id',
  StartAt = 'startAt',
  SubId = 'subId',
  UpdatedAt = 'updatedAt'
}

export type SubHistoryScalarWhereInput = {
  AND?: InputMaybe<Array<SubHistoryScalarWhereInput>>;
  NOT?: InputMaybe<Array<SubHistoryScalarWhereInput>>;
  OR?: InputMaybe<Array<SubHistoryScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  expiredAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  startAt?: InputMaybe<DateTimeFilter>;
  subId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type SubHistoryUpdateInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  expiredAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  startAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  sub?: InputMaybe<SubUpdateOneRequiredWithoutSubHistoriesNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SubHistoryUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  expiredAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  startAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SubHistoryUpdateManyWithWhereWithoutSubInput = {
  data: SubHistoryUpdateManyMutationInput;
  where: SubHistoryScalarWhereInput;
};

export type SubHistoryUpdateManyWithoutSubNestedInput = {
  connect?: InputMaybe<Array<SubHistoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SubHistoryCreateOrConnectWithoutSubInput>>;
  create?: InputMaybe<Array<SubHistoryCreateWithoutSubInput>>;
  createMany?: InputMaybe<SubHistoryCreateManySubInputEnvelope>;
  delete?: InputMaybe<Array<SubHistoryWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SubHistoryScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SubHistoryWhereUniqueInput>>;
  set?: InputMaybe<Array<SubHistoryWhereUniqueInput>>;
  update?: InputMaybe<Array<SubHistoryUpdateWithWhereUniqueWithoutSubInput>>;
  updateMany?: InputMaybe<Array<SubHistoryUpdateManyWithWhereWithoutSubInput>>;
  upsert?: InputMaybe<Array<SubHistoryUpsertWithWhereUniqueWithoutSubInput>>;
};

export type SubHistoryUpdateWithWhereUniqueWithoutSubInput = {
  data: SubHistoryUpdateWithoutSubInput;
  where: SubHistoryWhereUniqueInput;
};

export type SubHistoryUpdateWithoutSubInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  expiredAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  startAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SubHistoryUpsertWithWhereUniqueWithoutSubInput = {
  create: SubHistoryCreateWithoutSubInput;
  update: SubHistoryUpdateWithoutSubInput;
  where: SubHistoryWhereUniqueInput;
};

export type SubHistoryWhereInput = {
  AND?: InputMaybe<Array<SubHistoryWhereInput>>;
  NOT?: InputMaybe<Array<SubHistoryWhereInput>>;
  OR?: InputMaybe<Array<SubHistoryWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  expiredAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  startAt?: InputMaybe<DateTimeFilter>;
  sub?: InputMaybe<SubWhereInput>;
  subId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type SubHistoryWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
};

export type SubListRelationFilter = {
  every?: InputMaybe<SubWhereInput>;
  none?: InputMaybe<SubWhereInput>;
  some?: InputMaybe<SubWhereInput>;
};

export type SubOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SubOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  plan?: InputMaybe<PlanOrderByWithRelationInput>;
  planId?: InputMaybe<SortOrder>;
  status?: InputMaybe<SortOrder>;
  subHistories?: InputMaybe<SubHistoryOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationInput>;
  userId?: InputMaybe<SortOrder>;
};

export enum SubScalarFieldEnum {
  CreatedAt = 'createdAt',
  Id = 'id',
  PlanId = 'planId',
  Status = 'status',
  UpdatedAt = 'updatedAt',
  UserId = 'userId'
}

export type SubScalarWhereInput = {
  AND?: InputMaybe<Array<SubScalarWhereInput>>;
  NOT?: InputMaybe<Array<SubScalarWhereInput>>;
  OR?: InputMaybe<Array<SubScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  planId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumSubscriptionStatusFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type SubUpdateInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  plan?: InputMaybe<PlanUpdateOneRequiredWithoutSubscriptionsNestedInput>;
  status?: InputMaybe<EnumSubscriptionStatusFieldUpdateOperationsInput>;
  subHistories?: InputMaybe<SubHistoryUpdateManyWithoutSubNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutSubscriptionsNestedInput>;
};

export type SubUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSubscriptionStatusFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SubUpdateManyWithWhereWithoutPlanInput = {
  data: SubUpdateManyMutationInput;
  where: SubScalarWhereInput;
};

export type SubUpdateManyWithoutPlanNestedInput = {
  connect?: InputMaybe<Array<SubWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SubCreateOrConnectWithoutPlanInput>>;
  create?: InputMaybe<Array<SubCreateWithoutPlanInput>>;
  createMany?: InputMaybe<SubCreateManyPlanInputEnvelope>;
  delete?: InputMaybe<Array<SubWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SubScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SubWhereUniqueInput>>;
  set?: InputMaybe<Array<SubWhereUniqueInput>>;
  update?: InputMaybe<Array<SubUpdateWithWhereUniqueWithoutPlanInput>>;
  updateMany?: InputMaybe<Array<SubUpdateManyWithWhereWithoutPlanInput>>;
  upsert?: InputMaybe<Array<SubUpsertWithWhereUniqueWithoutPlanInput>>;
};

export type SubUpdateOneRequiredWithoutSubHistoriesNestedInput = {
  connect?: InputMaybe<SubWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SubCreateOrConnectWithoutSubHistoriesInput>;
  create?: InputMaybe<SubCreateWithoutSubHistoriesInput>;
  update?: InputMaybe<SubUpdateWithoutSubHistoriesInput>;
  upsert?: InputMaybe<SubUpsertWithoutSubHistoriesInput>;
};

export type SubUpdateWithWhereUniqueWithoutPlanInput = {
  data: SubUpdateWithoutPlanInput;
  where: SubWhereUniqueInput;
};

export type SubUpdateWithoutPlanInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSubscriptionStatusFieldUpdateOperationsInput>;
  subHistories?: InputMaybe<SubHistoryUpdateManyWithoutSubNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutSubscriptionsNestedInput>;
};

export type SubUpdateWithoutSubHistoriesInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  plan?: InputMaybe<PlanUpdateOneRequiredWithoutSubscriptionsNestedInput>;
  status?: InputMaybe<EnumSubscriptionStatusFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutSubscriptionsNestedInput>;
};

export type SubUpsertWithWhereUniqueWithoutPlanInput = {
  create: SubCreateWithoutPlanInput;
  update: SubUpdateWithoutPlanInput;
  where: SubWhereUniqueInput;
};

export type SubUpsertWithoutSubHistoriesInput = {
  create: SubCreateWithoutSubHistoriesInput;
  update: SubUpdateWithoutSubHistoriesInput;
};

export type SubWhereInput = {
  AND?: InputMaybe<Array<SubWhereInput>>;
  NOT?: InputMaybe<Array<SubWhereInput>>;
  OR?: InputMaybe<Array<SubWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  plan?: InputMaybe<PlanWhereInput>;
  planId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumSubscriptionStatusFilter>;
  subHistories?: InputMaybe<SubHistoryListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<StringFilter>;
};

export type SubWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['String']>;
};

export type Subscription = {
  postCreated: Post;
};

export enum SubscriptionStatus {
  Stop = 'Stop',
  Subscribe = 'Subscribe'
}

export type Token = {
  /** JWT access token */
  accessToken: Scalars['JWT'];
  /** JWT refresh token */
  refreshToken: Scalars['JWT'];
};

export type UpdateUserInput = {
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
};

export type User = {
  _count: UserCount;
  accountLicense?: Maybe<AccountLicense>;
  createdAt: Scalars['DateTime'];
  firstname?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  lastname?: Maybe<Scalars['String']>;
  password: Scalars['String'];
  posts?: Maybe<Array<Post>>;
  subscriptions?: Maybe<Array<Sub>>;
  updatedAt: Scalars['DateTime'];
  username: Scalars['String'];
};

export type UserConnection = {
  nodes?: Maybe<Array<User>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type UserCount = {
  posts: Scalars['Int'];
  subscriptions: Scalars['Int'];
};

export type UserCreateNestedOneWithoutSubscriptionsInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSubscriptionsInput>;
  create?: InputMaybe<UserCreateWithoutSubscriptionsInput>;
};

export type UserCreateOrConnectWithoutSubscriptionsInput = {
  create: UserCreateWithoutSubscriptionsInput;
  where: UserWhereUniqueInput;
};

export type UserCreateWithoutSubscriptionsInput = {
  accountLicense?: InputMaybe<AccountLicenseCreateNestedOneWithoutUserInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  firstname?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['String']>;
  lastname?: InputMaybe<Scalars['String']>;
  password: Scalars['String'];
  posts?: InputMaybe<PostCreateNestedManyWithoutAuthorInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  username: Scalars['String'];
};

export type UserOrderByWithRelationInput = {
  accountLicense?: InputMaybe<AccountLicenseOrderByWithRelationInput>;
  createdAt?: InputMaybe<SortOrder>;
  firstname?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastname?: InputMaybe<SortOrder>;
  password?: InputMaybe<SortOrder>;
  posts?: InputMaybe<PostOrderByRelationAggregateInput>;
  subscriptions?: InputMaybe<SubOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
  username?: InputMaybe<SortOrder>;
};

export enum UserScalarFieldEnum {
  CreatedAt = 'createdAt',
  Firstname = 'firstname',
  Id = 'id',
  Lastname = 'lastname',
  Password = 'password',
  UpdatedAt = 'updatedAt',
  Username = 'username'
}

export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSubscriptionsInput>;
  create?: InputMaybe<UserCreateWithoutSubscriptionsInput>;
  update?: InputMaybe<UserUpdateWithoutSubscriptionsInput>;
  upsert?: InputMaybe<UserUpsertWithoutSubscriptionsInput>;
};

export type UserUpdateWithoutSubscriptionsInput = {
  accountLicense?: InputMaybe<AccountLicenseUpdateOneWithoutUserNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  firstname?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastname?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  password?: InputMaybe<StringFieldUpdateOperationsInput>;
  posts?: InputMaybe<PostUpdateManyWithoutAuthorNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  username?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type UserUpsertWithoutSubscriptionsInput = {
  create: UserCreateWithoutSubscriptionsInput;
  update: UserUpdateWithoutSubscriptionsInput;
};

export type UserWhereInput = {
  AND?: InputMaybe<Array<UserWhereInput>>;
  NOT?: InputMaybe<Array<UserWhereInput>>;
  OR?: InputMaybe<Array<UserWhereInput>>;
  accountLicense?: InputMaybe<AccountLicenseWhereInput>;
  createdAt?: InputMaybe<DateTimeFilter>;
  firstname?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  lastname?: InputMaybe<StringNullableFilter>;
  password?: InputMaybe<StringFilter>;
  posts?: InputMaybe<PostListRelationFilter>;
  subscriptions?: InputMaybe<SubListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  username?: InputMaybe<StringFilter>;
};

export type UserWhereUniqueInput = {
  id?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
};

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { me: { id: string, username: string, firstname?: string | null | undefined, lastname?: string | null | undefined } };

export type LoginMutationVariables = Exact<{
  data: LoginInput;
}>;


export type LoginMutation = { login: { accessToken: any, refreshToken: any, user: { id: string, username: string } } };

export type SignupMutationVariables = Exact<{
  data: SignupInput;
}>;


export type SignupMutation = { signup: { accessToken: any, refreshToken: any, user: { id: string, username: string } } };

export type RefreshTokenMutationVariables = Exact<{
  token: Scalars['JWT'];
}>;


export type RefreshTokenMutation = { refreshToken: { accessToken: any, refreshToken: any } };

export type AssignUserMutationVariables = Exact<{
  rolename: Scalars['String'];
  username: Scalars['String'];
}>;


export type AssignUserMutation = { assignUser: boolean };

export type DeAssignUserMutationVariables = Exact<{
  rolename: Scalars['String'];
  username: Scalars['String'];
}>;


export type DeAssignUserMutation = { deAssignUser: boolean };

export type GrantPermissionMutationVariables = Exact<{
  object: Scalars['String'];
  operation: Scalars['String'];
  role: Scalars['String'];
}>;


export type GrantPermissionMutation = { grantPermission: boolean };

export type GrantPermissionsMutationVariables = Exact<{
  role: Scalars['String'];
  permissions: Array<PermissionInput> | PermissionInput;
}>;


export type GrantPermissionsMutation = { grantPermissions: boolean };

export type RevokePermissionMutationVariables = Exact<{
  object: Scalars['String'];
  operation: Scalars['String'];
  role: Scalars['String'];
}>;


export type RevokePermissionMutation = { revokePermission: boolean };

export type PlanFieldsFragment = { id: string, name: string, price: number, duration: Duration, createdAt: any, updatedAt: any };

export type PlansQueryVariables = Exact<{
  where?: InputMaybe<PlanWhereInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PlanOrderByWithRelationInput> | PlanOrderByWithRelationInput>;
}>;


export type PlansQuery = { plans: { totalCount: number, nodes?: Array<PlanFieldsFragment> | null | undefined, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean } } };

export type PlanQueryVariables = Exact<{
  where: PlanWhereUniqueInput;
}>;


export type PlanQuery = { plan: PlanFieldsFragment };

export type CreateOnePlanMutationVariables = Exact<{
  data: PlanCreateInput;
}>;


export type CreateOnePlanMutation = { createOnePlan: PlanFieldsFragment };

export type UpdateOnePlanMutationVariables = Exact<{
  where: PlanWhereUniqueInput;
  data: PlanUpdateInput;
}>;


export type UpdateOnePlanMutation = { updateOnePlan: PlanFieldsFragment };

export type DeleteOnePlanMutationVariables = Exact<{
  where: PlanWhereUniqueInput;
}>;


export type DeleteOnePlanMutation = { deleteOnePlan: PlanFieldsFragment };

export type RoleFieldsFragment = { id: string, name: string, description: string, createdAt: any };

export type RolesQueryVariables = Exact<{
  where?: InputMaybe<RoleWhereInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RoleOrderByWithRelationInput> | RoleOrderByWithRelationInput>;
}>;


export type RolesQuery = { roles: { totalCount: number, nodes?: Array<RoleFieldsFragment> | null | undefined, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean } } };

export type RoleQueryVariables = Exact<{
  where: RoleWhereUniqueInput;
}>;


export type RoleQuery = { role: RoleFieldsFragment };

export type GetUserRolesQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type GetUserRolesQuery = { getUserRoles: Array<string> };

export type GetRolePermissionsQueryVariables = Exact<{
  rolename: Scalars['String'];
}>;


export type GetRolePermissionsQuery = { getRolePermissions: Array<Array<string>> };

export type GetUserPermissionsQueryVariables = Exact<{
  username: Scalars['String'];
}>;


export type GetUserPermissionsQuery = { getUserPermissions: Array<Array<string>> };

export type CreateOneRoleMutationVariables = Exact<{
  data: RoleCreateInput;
}>;


export type CreateOneRoleMutation = { createOneRole: RoleFieldsFragment };

export type UpdateOneRoleMutationVariables = Exact<{
  where: RoleWhereUniqueInput;
  data: RoleUpdateInput;
}>;


export type UpdateOneRoleMutation = { updateOneRole: RoleFieldsFragment };

export type DeleteOneRoleMutationVariables = Exact<{
  name: Scalars['String'];
}>;


export type DeleteOneRoleMutation = { deleteOneRole: RoleFieldsFragment };

export type SubHistoryFieldFragment = { id: string, startAt: any, expiredAt: any };

export type SubHistoriesQueryVariables = Exact<{
  where?: InputMaybe<SubHistoryWhereInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SubHistoryOrderByWithRelationInput> | SubHistoryOrderByWithRelationInput>;
}>;


export type SubHistoriesQuery = { subHistories: { totalCount: number, nodes?: Array<SubHistoryFieldFragment> | null | undefined, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean } } };

export type SubHistoryQueryVariables = Exact<{
  where: SubHistoryWhereUniqueInput;
}>;


export type SubHistoryQuery = { subHistory: SubHistoryFieldFragment };

export type CreateOneSubHistoryMutationVariables = Exact<{
  data: SubHistoryCreateInput;
}>;


export type CreateOneSubHistoryMutation = { createOneSubHistory: SubHistoryFieldFragment };

export type UpdateOneSubHistoryMutationVariables = Exact<{
  where: SubHistoryWhereUniqueInput;
  data: SubHistoryUpdateInput;
}>;


export type UpdateOneSubHistoryMutation = { updateOneSubHistory: SubHistoryFieldFragment };

export type DeleteOneSubHistoryMutationVariables = Exact<{
  where: SubHistoryWhereUniqueInput;
}>;


export type DeleteOneSubHistoryMutation = { deleteOneSubHistory: SubHistoryFieldFragment };

export type SubFieldsFragment = { id: string, status: SubscriptionStatus, createdAt: any, updatedAt: any, plan: PlanFieldsFragment, user: UserFieldsFragment, subHistories?: Array<SubHistoryFieldFragment> | null | undefined };

export type SubsQueryVariables = Exact<{
  where?: InputMaybe<SubWhereInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SubOrderByWithRelationInput> | SubOrderByWithRelationInput>;
}>;


export type SubsQuery = { subs: { totalCount: number, nodes?: Array<SubFieldsFragment> | null | undefined, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean } } };

export type SubQueryVariables = Exact<{
  where: SubWhereUniqueInput;
}>;


export type SubQuery = { sub: SubFieldsFragment };

export type CreateOneSubMutationVariables = Exact<{
  data: SubCreateInput;
}>;


export type CreateOneSubMutation = { createOneSub: SubFieldsFragment };

export type UpdateOneSubMutationVariables = Exact<{
  where: SubWhereUniqueInput;
  data: SubUpdateInput;
}>;


export type UpdateOneSubMutation = { updateOneSub: SubFieldsFragment };

export type DeleteOneSubMutationVariables = Exact<{
  where: SubWhereUniqueInput;
}>;


export type DeleteOneSubMutation = { deleteOneSub: SubFieldsFragment };

export type UserFieldsFragment = { id: string, firstname?: string | null | undefined, lastname?: string | null | undefined, username: string };

export type UsersQueryVariables = Exact<{
  where?: InputMaybe<UserWhereInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput> | UserOrderByWithRelationInput>;
}>;


export type UsersQuery = { users: { totalCount: number, nodes?: Array<UserFieldsFragment> | null | undefined, pageInfo: { hasNextPage: boolean, hasPreviousPage: boolean } } };

export const RoleFieldsFragmentDoc = `
    fragment RoleFields on Role {
  id
  name
  description
  createdAt
}
    `;
export const PlanFieldsFragmentDoc = `
    fragment PlanFields on Plan {
  id
  name
  price
  duration
  createdAt
  updatedAt
}
    `;
export const UserFieldsFragmentDoc = `
    fragment UserFields on User {
  id
  firstname
  lastname
  username
}
    `;
export const SubHistoryFieldFragmentDoc = `
    fragment SubHistoryField on SubHistory {
  id
  startAt
  expiredAt
}
    `;
export const SubFieldsFragmentDoc = `
    fragment SubFields on Sub {
  id
  plan {
    ...PlanFields
  }
  user {
    ...UserFields
  }
  subHistories {
    ...SubHistoryField
  }
  status
  createdAt
  updatedAt
}
    ${PlanFieldsFragmentDoc}
${UserFieldsFragmentDoc}
${SubHistoryFieldFragmentDoc}`;
export const MeDocument = `
    query me {
  me {
    id
    username
    firstname
    lastname
  }
}
    `;
export const useMeQuery = <
      TData = MeQuery,
      TError = unknown
    >(
      variables?: MeQueryVariables,
      options?: UseQueryOptions<MeQuery, TError, TData>
    ) =>
    useQuery<MeQuery, TError, TData>(
      variables === undefined ? ['me'] : ['me', variables],
      useFetchData<MeQuery, MeQueryVariables>(MeDocument).bind(null, variables),
      options
    );
export const LoginDocument = `
    mutation login($data: LoginInput!) {
  login(data: $data) {
    accessToken
    refreshToken
    user {
      id
      username
    }
  }
}
    `;
export const useLoginMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<LoginMutation, TError, LoginMutationVariables, TContext>) =>
    useMutation<LoginMutation, TError, LoginMutationVariables, TContext>(
      ['login'],
      useFetchData<LoginMutation, LoginMutationVariables>(LoginDocument),
      options
    );
export const SignupDocument = `
    mutation signup($data: SignupInput!) {
  signup(data: $data) {
    accessToken
    refreshToken
    user {
      id
      username
    }
  }
}
    `;
export const useSignupMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<SignupMutation, TError, SignupMutationVariables, TContext>) =>
    useMutation<SignupMutation, TError, SignupMutationVariables, TContext>(
      ['signup'],
      useFetchData<SignupMutation, SignupMutationVariables>(SignupDocument),
      options
    );
export const RefreshTokenDocument = `
    mutation refreshToken($token: JWT!) {
  refreshToken(token: $token) {
    accessToken
    refreshToken
  }
}
    `;
export const useRefreshTokenMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<RefreshTokenMutation, TError, RefreshTokenMutationVariables, TContext>) =>
    useMutation<RefreshTokenMutation, TError, RefreshTokenMutationVariables, TContext>(
      ['refreshToken'],
      useFetchData<RefreshTokenMutation, RefreshTokenMutationVariables>(RefreshTokenDocument),
      options
    );
export const AssignUserDocument = `
    mutation assignUser($rolename: String!, $username: String!) {
  assignUser(rolename: $rolename, username: $username)
}
    `;
export const useAssignUserMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<AssignUserMutation, TError, AssignUserMutationVariables, TContext>) =>
    useMutation<AssignUserMutation, TError, AssignUserMutationVariables, TContext>(
      ['assignUser'],
      useFetchData<AssignUserMutation, AssignUserMutationVariables>(AssignUserDocument),
      options
    );
export const DeAssignUserDocument = `
    mutation deAssignUser($rolename: String!, $username: String!) {
  deAssignUser(rolename: $rolename, username: $username)
}
    `;
export const useDeAssignUserMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeAssignUserMutation, TError, DeAssignUserMutationVariables, TContext>) =>
    useMutation<DeAssignUserMutation, TError, DeAssignUserMutationVariables, TContext>(
      ['deAssignUser'],
      useFetchData<DeAssignUserMutation, DeAssignUserMutationVariables>(DeAssignUserDocument),
      options
    );
export const GrantPermissionDocument = `
    mutation grantPermission($object: String!, $operation: String!, $role: String!) {
  grantPermission(object: $object, operation: $operation, role: $role)
}
    `;
export const useGrantPermissionMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<GrantPermissionMutation, TError, GrantPermissionMutationVariables, TContext>) =>
    useMutation<GrantPermissionMutation, TError, GrantPermissionMutationVariables, TContext>(
      ['grantPermission'],
      useFetchData<GrantPermissionMutation, GrantPermissionMutationVariables>(GrantPermissionDocument),
      options
    );
export const GrantPermissionsDocument = `
    mutation grantPermissions($role: String!, $permissions: [PermissionInput!]!) {
  grantPermissions(role: $role, permissions: $permissions)
}
    `;
export const useGrantPermissionsMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<GrantPermissionsMutation, TError, GrantPermissionsMutationVariables, TContext>) =>
    useMutation<GrantPermissionsMutation, TError, GrantPermissionsMutationVariables, TContext>(
      ['grantPermissions'],
      useFetchData<GrantPermissionsMutation, GrantPermissionsMutationVariables>(GrantPermissionsDocument),
      options
    );
export const RevokePermissionDocument = `
    mutation revokePermission($object: String!, $operation: String!, $role: String!) {
  revokePermission(object: $object, operation: $operation, role: $role)
}
    `;
export const useRevokePermissionMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<RevokePermissionMutation, TError, RevokePermissionMutationVariables, TContext>) =>
    useMutation<RevokePermissionMutation, TError, RevokePermissionMutationVariables, TContext>(
      ['revokePermission'],
      useFetchData<RevokePermissionMutation, RevokePermissionMutationVariables>(RevokePermissionDocument),
      options
    );
export const PlansDocument = `
    query plans($where: PlanWhereInput, $skip: Int, $take: Int, $orderBy: [PlanOrderByWithRelationInput!]) {
  plans(where: $where, skip: $skip, take: $take, orderBy: $orderBy) {
    nodes {
      ...PlanFields
    }
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
  }
}
    ${PlanFieldsFragmentDoc}`;
export const usePlansQuery = <
      TData = PlansQuery,
      TError = unknown
    >(
      variables?: PlansQueryVariables,
      options?: UseQueryOptions<PlansQuery, TError, TData>
    ) =>
    useQuery<PlansQuery, TError, TData>(
      variables === undefined ? ['plans'] : ['plans', variables],
      useFetchData<PlansQuery, PlansQueryVariables>(PlansDocument).bind(null, variables),
      options
    );
export const PlanDocument = `
    query plan($where: PlanWhereUniqueInput!) {
  plan(where: $where) {
    ...PlanFields
  }
}
    ${PlanFieldsFragmentDoc}`;
export const usePlanQuery = <
      TData = PlanQuery,
      TError = unknown
    >(
      variables: PlanQueryVariables,
      options?: UseQueryOptions<PlanQuery, TError, TData>
    ) =>
    useQuery<PlanQuery, TError, TData>(
      ['plan', variables],
      useFetchData<PlanQuery, PlanQueryVariables>(PlanDocument).bind(null, variables),
      options
    );
export const CreateOnePlanDocument = `
    mutation createOnePlan($data: PlanCreateInput!) {
  createOnePlan(data: $data) {
    ...PlanFields
  }
}
    ${PlanFieldsFragmentDoc}`;
export const useCreateOnePlanMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateOnePlanMutation, TError, CreateOnePlanMutationVariables, TContext>) =>
    useMutation<CreateOnePlanMutation, TError, CreateOnePlanMutationVariables, TContext>(
      ['createOnePlan'],
      useFetchData<CreateOnePlanMutation, CreateOnePlanMutationVariables>(CreateOnePlanDocument),
      options
    );
export const UpdateOnePlanDocument = `
    mutation updateOnePlan($where: PlanWhereUniqueInput!, $data: PlanUpdateInput!) {
  updateOnePlan(where: $where, data: $data) {
    ...PlanFields
  }
}
    ${PlanFieldsFragmentDoc}`;
export const useUpdateOnePlanMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateOnePlanMutation, TError, UpdateOnePlanMutationVariables, TContext>) =>
    useMutation<UpdateOnePlanMutation, TError, UpdateOnePlanMutationVariables, TContext>(
      ['updateOnePlan'],
      useFetchData<UpdateOnePlanMutation, UpdateOnePlanMutationVariables>(UpdateOnePlanDocument),
      options
    );
export const DeleteOnePlanDocument = `
    mutation deleteOnePlan($where: PlanWhereUniqueInput!) {
  deleteOnePlan(where: $where) {
    ...PlanFields
  }
}
    ${PlanFieldsFragmentDoc}`;
export const useDeleteOnePlanMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteOnePlanMutation, TError, DeleteOnePlanMutationVariables, TContext>) =>
    useMutation<DeleteOnePlanMutation, TError, DeleteOnePlanMutationVariables, TContext>(
      ['deleteOnePlan'],
      useFetchData<DeleteOnePlanMutation, DeleteOnePlanMutationVariables>(DeleteOnePlanDocument),
      options
    );
export const RolesDocument = `
    query roles($where: RoleWhereInput, $skip: Int, $take: Int, $orderBy: [RoleOrderByWithRelationInput!]) {
  roles(where: $where, skip: $skip, take: $take, orderBy: $orderBy) {
    nodes {
      ...RoleFields
    }
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
  }
}
    ${RoleFieldsFragmentDoc}`;
export const useRolesQuery = <
      TData = RolesQuery,
      TError = unknown
    >(
      variables?: RolesQueryVariables,
      options?: UseQueryOptions<RolesQuery, TError, TData>
    ) =>
    useQuery<RolesQuery, TError, TData>(
      variables === undefined ? ['roles'] : ['roles', variables],
      useFetchData<RolesQuery, RolesQueryVariables>(RolesDocument).bind(null, variables),
      options
    );
export const RoleDocument = `
    query role($where: RoleWhereUniqueInput!) {
  role(where: $where) {
    ...RoleFields
  }
}
    ${RoleFieldsFragmentDoc}`;
export const useRoleQuery = <
      TData = RoleQuery,
      TError = unknown
    >(
      variables: RoleQueryVariables,
      options?: UseQueryOptions<RoleQuery, TError, TData>
    ) =>
    useQuery<RoleQuery, TError, TData>(
      ['role', variables],
      useFetchData<RoleQuery, RoleQueryVariables>(RoleDocument).bind(null, variables),
      options
    );
export const GetUserRolesDocument = `
    query getUserRoles($username: String!) {
  getUserRoles(username: $username)
}
    `;
export const useGetUserRolesQuery = <
      TData = GetUserRolesQuery,
      TError = unknown
    >(
      variables: GetUserRolesQueryVariables,
      options?: UseQueryOptions<GetUserRolesQuery, TError, TData>
    ) =>
    useQuery<GetUserRolesQuery, TError, TData>(
      ['getUserRoles', variables],
      useFetchData<GetUserRolesQuery, GetUserRolesQueryVariables>(GetUserRolesDocument).bind(null, variables),
      options
    );
export const GetRolePermissionsDocument = `
    query getRolePermissions($rolename: String!) {
  getRolePermissions(rolename: $rolename)
}
    `;
export const useGetRolePermissionsQuery = <
      TData = GetRolePermissionsQuery,
      TError = unknown
    >(
      variables: GetRolePermissionsQueryVariables,
      options?: UseQueryOptions<GetRolePermissionsQuery, TError, TData>
    ) =>
    useQuery<GetRolePermissionsQuery, TError, TData>(
      ['getRolePermissions', variables],
      useFetchData<GetRolePermissionsQuery, GetRolePermissionsQueryVariables>(GetRolePermissionsDocument).bind(null, variables),
      options
    );
export const GetUserPermissionsDocument = `
    query getUserPermissions($username: String!) {
  getUserPermissions(username: $username)
}
    `;
export const useGetUserPermissionsQuery = <
      TData = GetUserPermissionsQuery,
      TError = unknown
    >(
      variables: GetUserPermissionsQueryVariables,
      options?: UseQueryOptions<GetUserPermissionsQuery, TError, TData>
    ) =>
    useQuery<GetUserPermissionsQuery, TError, TData>(
      ['getUserPermissions', variables],
      useFetchData<GetUserPermissionsQuery, GetUserPermissionsQueryVariables>(GetUserPermissionsDocument).bind(null, variables),
      options
    );
export const CreateOneRoleDocument = `
    mutation createOneRole($data: RoleCreateInput!) {
  createOneRole(data: $data) {
    ...RoleFields
  }
}
    ${RoleFieldsFragmentDoc}`;
export const useCreateOneRoleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateOneRoleMutation, TError, CreateOneRoleMutationVariables, TContext>) =>
    useMutation<CreateOneRoleMutation, TError, CreateOneRoleMutationVariables, TContext>(
      ['createOneRole'],
      useFetchData<CreateOneRoleMutation, CreateOneRoleMutationVariables>(CreateOneRoleDocument),
      options
    );
export const UpdateOneRoleDocument = `
    mutation updateOneRole($where: RoleWhereUniqueInput!, $data: RoleUpdateInput!) {
  updateOneRole(where: $where, data: $data) {
    ...RoleFields
  }
}
    ${RoleFieldsFragmentDoc}`;
export const useUpdateOneRoleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateOneRoleMutation, TError, UpdateOneRoleMutationVariables, TContext>) =>
    useMutation<UpdateOneRoleMutation, TError, UpdateOneRoleMutationVariables, TContext>(
      ['updateOneRole'],
      useFetchData<UpdateOneRoleMutation, UpdateOneRoleMutationVariables>(UpdateOneRoleDocument),
      options
    );
export const DeleteOneRoleDocument = `
    mutation deleteOneRole($name: String!) {
  deleteOneRole(name: $name) {
    ...RoleFields
  }
}
    ${RoleFieldsFragmentDoc}`;
export const useDeleteOneRoleMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteOneRoleMutation, TError, DeleteOneRoleMutationVariables, TContext>) =>
    useMutation<DeleteOneRoleMutation, TError, DeleteOneRoleMutationVariables, TContext>(
      ['deleteOneRole'],
      useFetchData<DeleteOneRoleMutation, DeleteOneRoleMutationVariables>(DeleteOneRoleDocument),
      options
    );
export const SubHistoriesDocument = `
    query subHistories($where: SubHistoryWhereInput, $skip: Int, $take: Int, $orderBy: [SubHistoryOrderByWithRelationInput!]) {
  subHistories(where: $where, skip: $skip, take: $take, orderBy: $orderBy) {
    nodes {
      ...SubHistoryField
    }
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
  }
}
    ${SubHistoryFieldFragmentDoc}`;
export const useSubHistoriesQuery = <
      TData = SubHistoriesQuery,
      TError = unknown
    >(
      variables?: SubHistoriesQueryVariables,
      options?: UseQueryOptions<SubHistoriesQuery, TError, TData>
    ) =>
    useQuery<SubHistoriesQuery, TError, TData>(
      variables === undefined ? ['subHistories'] : ['subHistories', variables],
      useFetchData<SubHistoriesQuery, SubHistoriesQueryVariables>(SubHistoriesDocument).bind(null, variables),
      options
    );
export const SubHistoryDocument = `
    query subHistory($where: SubHistoryWhereUniqueInput!) {
  subHistory(where: $where) {
    ...SubHistoryField
  }
}
    ${SubHistoryFieldFragmentDoc}`;
export const useSubHistoryQuery = <
      TData = SubHistoryQuery,
      TError = unknown
    >(
      variables: SubHistoryQueryVariables,
      options?: UseQueryOptions<SubHistoryQuery, TError, TData>
    ) =>
    useQuery<SubHistoryQuery, TError, TData>(
      ['subHistory', variables],
      useFetchData<SubHistoryQuery, SubHistoryQueryVariables>(SubHistoryDocument).bind(null, variables),
      options
    );
export const CreateOneSubHistoryDocument = `
    mutation createOneSubHistory($data: SubHistoryCreateInput!) {
  createOneSubHistory(data: $data) {
    ...SubHistoryField
  }
}
    ${SubHistoryFieldFragmentDoc}`;
export const useCreateOneSubHistoryMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateOneSubHistoryMutation, TError, CreateOneSubHistoryMutationVariables, TContext>) =>
    useMutation<CreateOneSubHistoryMutation, TError, CreateOneSubHistoryMutationVariables, TContext>(
      ['createOneSubHistory'],
      useFetchData<CreateOneSubHistoryMutation, CreateOneSubHistoryMutationVariables>(CreateOneSubHistoryDocument),
      options
    );
export const UpdateOneSubHistoryDocument = `
    mutation updateOneSubHistory($where: SubHistoryWhereUniqueInput!, $data: SubHistoryUpdateInput!) {
  updateOneSubHistory(where: $where, data: $data) {
    ...SubHistoryField
  }
}
    ${SubHistoryFieldFragmentDoc}`;
export const useUpdateOneSubHistoryMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateOneSubHistoryMutation, TError, UpdateOneSubHistoryMutationVariables, TContext>) =>
    useMutation<UpdateOneSubHistoryMutation, TError, UpdateOneSubHistoryMutationVariables, TContext>(
      ['updateOneSubHistory'],
      useFetchData<UpdateOneSubHistoryMutation, UpdateOneSubHistoryMutationVariables>(UpdateOneSubHistoryDocument),
      options
    );
export const DeleteOneSubHistoryDocument = `
    mutation deleteOneSubHistory($where: SubHistoryWhereUniqueInput!) {
  deleteOneSubHistory(where: $where) {
    ...SubHistoryField
  }
}
    ${SubHistoryFieldFragmentDoc}`;
export const useDeleteOneSubHistoryMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteOneSubHistoryMutation, TError, DeleteOneSubHistoryMutationVariables, TContext>) =>
    useMutation<DeleteOneSubHistoryMutation, TError, DeleteOneSubHistoryMutationVariables, TContext>(
      ['deleteOneSubHistory'],
      useFetchData<DeleteOneSubHistoryMutation, DeleteOneSubHistoryMutationVariables>(DeleteOneSubHistoryDocument),
      options
    );
export const SubsDocument = `
    query subs($where: SubWhereInput, $skip: Int, $take: Int, $orderBy: [SubOrderByWithRelationInput!]) {
  subs(where: $where, skip: $skip, take: $take, orderBy: $orderBy) {
    nodes {
      ...SubFields
    }
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
  }
}
    ${SubFieldsFragmentDoc}`;
export const useSubsQuery = <
      TData = SubsQuery,
      TError = unknown
    >(
      variables?: SubsQueryVariables,
      options?: UseQueryOptions<SubsQuery, TError, TData>
    ) =>
    useQuery<SubsQuery, TError, TData>(
      variables === undefined ? ['subs'] : ['subs', variables],
      useFetchData<SubsQuery, SubsQueryVariables>(SubsDocument).bind(null, variables),
      options
    );
export const SubDocument = `
    query sub($where: SubWhereUniqueInput!) {
  sub(where: $where) {
    ...SubFields
  }
}
    ${SubFieldsFragmentDoc}`;
export const useSubQuery = <
      TData = SubQuery,
      TError = unknown
    >(
      variables: SubQueryVariables,
      options?: UseQueryOptions<SubQuery, TError, TData>
    ) =>
    useQuery<SubQuery, TError, TData>(
      ['sub', variables],
      useFetchData<SubQuery, SubQueryVariables>(SubDocument).bind(null, variables),
      options
    );
export const CreateOneSubDocument = `
    mutation createOneSub($data: SubCreateInput!) {
  createOneSub(data: $data) {
    ...SubFields
  }
}
    ${SubFieldsFragmentDoc}`;
export const useCreateOneSubMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreateOneSubMutation, TError, CreateOneSubMutationVariables, TContext>) =>
    useMutation<CreateOneSubMutation, TError, CreateOneSubMutationVariables, TContext>(
      ['createOneSub'],
      useFetchData<CreateOneSubMutation, CreateOneSubMutationVariables>(CreateOneSubDocument),
      options
    );
export const UpdateOneSubDocument = `
    mutation updateOneSub($where: SubWhereUniqueInput!, $data: SubUpdateInput!) {
  updateOneSub(where: $where, data: $data) {
    ...SubFields
  }
}
    ${SubFieldsFragmentDoc}`;
export const useUpdateOneSubMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UpdateOneSubMutation, TError, UpdateOneSubMutationVariables, TContext>) =>
    useMutation<UpdateOneSubMutation, TError, UpdateOneSubMutationVariables, TContext>(
      ['updateOneSub'],
      useFetchData<UpdateOneSubMutation, UpdateOneSubMutationVariables>(UpdateOneSubDocument),
      options
    );
export const DeleteOneSubDocument = `
    mutation deleteOneSub($where: SubWhereUniqueInput!) {
  deleteOneSub(where: $where) {
    ...SubFields
  }
}
    ${SubFieldsFragmentDoc}`;
export const useDeleteOneSubMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteOneSubMutation, TError, DeleteOneSubMutationVariables, TContext>) =>
    useMutation<DeleteOneSubMutation, TError, DeleteOneSubMutationVariables, TContext>(
      ['deleteOneSub'],
      useFetchData<DeleteOneSubMutation, DeleteOneSubMutationVariables>(DeleteOneSubDocument),
      options
    );
export const UsersDocument = `
    query users($where: UserWhereInput, $skip: Int, $take: Int, $orderBy: [UserOrderByWithRelationInput!]) {
  users(where: $where, skip: $skip, take: $take, orderBy: $orderBy) {
    nodes {
      ...UserFields
    }
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
    }
  }
}
    ${UserFieldsFragmentDoc}`;
export const useUsersQuery = <
      TData = UsersQuery,
      TError = unknown
    >(
      variables?: UsersQueryVariables,
      options?: UseQueryOptions<UsersQuery, TError, TData>
    ) =>
    useQuery<UsersQuery, TError, TData>(
      variables === undefined ? ['users'] : ['users', variables],
      useFetchData<UsersQuery, UsersQueryVariables>(UsersDocument).bind(null, variables),
      options
    );