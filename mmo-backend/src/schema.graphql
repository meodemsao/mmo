# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AccountLicense {
  createdAt: DateTime!
  id: ID!
  licenseId: String!
  updatedAt: DateTime!
  user: User
  userId: String!
}

input AccountLicenseCreateNestedOneWithoutUserInput {
  connect: AccountLicenseWhereUniqueInput
  connectOrCreate: AccountLicenseCreateOrConnectWithoutUserInput
  create: AccountLicenseCreateWithoutUserInput
}

input AccountLicenseCreateOrConnectWithoutUserInput {
  create: AccountLicenseCreateWithoutUserInput!
  where: AccountLicenseWhereUniqueInput!
}

input AccountLicenseCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  licenseId: String!
  updatedAt: DateTime
}

input AccountLicenseOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  licenseId: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input AccountLicenseUpdateOneWithoutUserNestedInput {
  connect: AccountLicenseWhereUniqueInput
  connectOrCreate: AccountLicenseCreateOrConnectWithoutUserInput
  create: AccountLicenseCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: AccountLicenseUpdateWithoutUserInput
  upsert: AccountLicenseUpsertWithoutUserInput
}

input AccountLicenseUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  licenseId: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AccountLicenseUpsertWithoutUserInput {
  create: AccountLicenseCreateWithoutUserInput!
  update: AccountLicenseUpdateWithoutUserInput!
}

input AccountLicenseWhereInput {
  AND: [AccountLicenseWhereInput!]
  NOT: [AccountLicenseWhereInput!]
  OR: [AccountLicenseWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  licenseId: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input AccountLicenseWhereUniqueInput {
  id: String
  licenseId: String
  userId: String
}

type Auth {
  """JWT access token"""
  accessToken: JWT!

  """JWT refresh token"""
  refreshToken: JWT!
  user: User!
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Category {
  _count: CategoryCount!
  createdAt: DateTime!
  id: ID!
  name: String!
  products: [ProductCategory!]
  updatedAt: DateTime!
}

type CategoryConnection {
  nodes: [Category!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CategoryCount {
  products: Int!
}

input CategoryCreateInput {
  createdAt: DateTime
  id: String
  name: String!
  products: ProductCategoryCreateNestedManyWithoutCategoryInput
  updatedAt: DateTime
}

input CategoryCreateNestedOneWithoutProductsInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutProductsInput
  create: CategoryCreateWithoutProductsInput
}

input CategoryCreateOrConnectWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateWithoutProductsInput {
  createdAt: DateTime
  id: String
  name: String!
  updatedAt: DateTime
}

input CategoryOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  products: ProductCategoryOrderByRelationAggregateInput
  updatedAt: SortOrder
}

enum CategoryScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input CategoryUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  products: ProductCategoryUpdateManyWithoutCategoryNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CategoryUpdateOneRequiredWithoutProductsNestedInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutProductsInput
  create: CategoryCreateWithoutProductsInput
  update: CategoryUpdateWithoutProductsInput
  upsert: CategoryUpsertWithoutProductsInput
}

input CategoryUpdateWithoutProductsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CategoryUpsertWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput!
  update: CategoryUpdateWithoutProductsInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  products: ProductCategoryListRelationFilter
  updatedAt: DateTimeFilter
}

input CategoryWhereUniqueInput {
  id: String
}

input ChangePasswordInput {
  newPassword: String!
  oldPassword: String!
}

input CreatePostInput {
  content: String!
  title: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

enum Duration {
  Month
  Year
}

input EnumDurationFieldUpdateOperationsInput {
  set: Duration
}

input EnumDurationFilter {
  equals: Duration
  in: [Duration!]
  not: NestedEnumDurationFilter
  notIn: [Duration!]
}

input EnumOrderStatusFilter {
  equals: OrderStatus
  in: [OrderStatus!]
  not: NestedEnumOrderStatusFilter
  notIn: [OrderStatus!]
}

input EnumSubscriptionStatusFieldUpdateOperationsInput {
  set: SubscriptionStatus
}

input EnumSubscriptionStatusFilter {
  equals: SubscriptionStatus
  in: [SubscriptionStatus!]
  not: NestedEnumSubscriptionStatusFilter
  notIn: [SubscriptionStatus!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

"""
A field whose value is a JSON Web Token (JWT): https://jwt.io/introduction.
"""
scalar JWT

type License {
  createdAt: DateTime!
  id: ID!
  key: String!
  updatedAt: DateTime!
}

type LicenseConnection {
  nodes: [License!]
  pageInfo: PageInfo!
  totalCount: Int!
}

input LicenseCreateInput {
  createdAt: DateTime
  id: String
  key: String!
  updatedAt: DateTime
}

input LicenseOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  key: SortOrder
  updatedAt: SortOrder
}

enum LicenseScalarFieldEnum {
  createdAt
  id
  key
  updatedAt
}

input LicenseUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  key: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LicenseWhereInput {
  AND: [LicenseWhereInput!]
  NOT: [LicenseWhereInput!]
  OR: [LicenseWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  key: StringFilter
  updatedAt: DateTimeFilter
}

input LicenseWhereUniqueInput {
  id: String
  key: String
}

input LoginInput {
  password: String!
  username: String!
}

type Mutation {
  assignUser(rolename: String!, username: String!): Boolean!
  changePassword(data: ChangePasswordInput!): User!
  createOneCategory(data: CategoryCreateInput!): Category!
  createOneLicense(data: LicenseCreateInput!): License!
  createOnePlan(data: PlanCreateInput!): Plan!
  createOneProduct(data: ProductCreateInput!): Product!
  createOneRole(data: RoleCreateInput!): Role!
  createOneSub(data: SubCreateInput!): Sub!
  createOneSubHistory(data: SubHistoryCreateInput!): SubHistory!
  createPost(data: CreatePostInput!): Post!
  deAssignUser(rolename: String!, username: String!): Boolean!
  deleteOneCategory(where: CategoryWhereUniqueInput!): Category!
  deleteOneLicense(where: LicenseWhereUniqueInput!): License!
  deleteOnePlan(where: PlanWhereUniqueInput!): Plan!
  deleteOneRole(name: String!): Role!
  deleteOneSub(where: SubWhereUniqueInput!): Sub!
  deleteOneSubHistory(where: SubHistoryWhereUniqueInput!): SubHistory!
  grantPermission(object: String!, operation: String!, role: String!): Boolean!
  grantPermissions(permissions: [PermissionInput!]!, role: String!): Boolean!
  login(data: LoginInput!): Auth!
  refreshToken(token: JWT!): Token!
  revokePermission(object: String!, operation: String!, role: String!): Boolean!
  signup(data: SignupInput!): Auth!
  updateOneCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  updateOneLicense(data: LicenseUpdateInput!, where: LicenseWhereUniqueInput!): License!
  updateOnePlan(data: PlanUpdateInput!, where: PlanWhereUniqueInput!): Plan!
  updateOneRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role!
  updateOneSub(data: SubUpdateInput!, where: SubWhereUniqueInput!): Sub!
  updateOneSubHistory(data: SubHistoryUpdateInput!, where: SubHistoryWhereUniqueInput!): SubHistory!
  updateUser(data: UpdateUserInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumDurationFilter {
  equals: Duration
  in: [Duration!]
  not: NestedEnumDurationFilter
  notIn: [Duration!]
}

input NestedEnumOrderStatusFilter {
  equals: OrderStatus
  in: [OrderStatus!]
  not: NestedEnumOrderStatusFilter
  notIn: [OrderStatus!]
}

input NestedEnumSubscriptionStatusFilter {
  equals: SubscriptionStatus
  in: [SubscriptionStatus!]
  not: NestedEnumSubscriptionStatusFilter
  notIn: [SubscriptionStatus!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Order {
  _count: OrderCount!
  countryCode: String!
  couponId: String!
  createdAt: DateTime!
  delivered: Boolean!
  email: String!
  exchangeRate: Int!
  gateway: String!
  id: ID!
  ipAddress: String!
  orderItems: [OrderItem!]
  productTitle: String!
  referral: String!
  riskLevel: Int!
  status: OrderStatus!
  updatedAt: DateTime!
  usdValue: Int!
  userAgent: String!
}

type OrderConnection {
  nodes: [Order!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrderCount {
  orderItems: Int!
}

type OrderItem {
  createdAt: DateTime!
  currency: String!
  id: ID!
  order: Order!
  orderId: String!
  quantity: Int!
  updatedAt: DateTime!
  value: Int!
}

input OrderItemListRelationFilter {
  every: OrderItemWhereInput
  none: OrderItemWhereInput
  some: OrderItemWhereInput
}

input OrderItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input OrderItemWhereInput {
  AND: [OrderItemWhereInput!]
  NOT: [OrderItemWhereInput!]
  OR: [OrderItemWhereInput!]
  createdAt: DateTimeFilter
  currency: StringFilter
  id: StringFilter
  order: OrderWhereInput
  orderId: StringFilter
  quantity: IntFilter
  updatedAt: DateTimeFilter
  value: IntFilter
}

input OrderOrderByWithRelationInput {
  countryCode: SortOrder
  couponId: SortOrder
  createdAt: SortOrder
  delivered: SortOrder
  email: SortOrder
  exchangeRate: SortOrder
  gateway: SortOrder
  id: SortOrder
  ipAddress: SortOrder
  orderItems: OrderItemOrderByRelationAggregateInput
  productTitle: SortOrder
  referral: SortOrder
  riskLevel: SortOrder
  status: SortOrder
  updatedAt: SortOrder
  usdValue: SortOrder
  userAgent: SortOrder
}

enum OrderScalarFieldEnum {
  countryCode
  couponId
  createdAt
  delivered
  email
  exchangeRate
  gateway
  id
  ipAddress
  productTitle
  referral
  riskLevel
  status
  updatedAt
  usdValue
  userAgent
}

enum OrderStatus {
  awaitingPaymentConfirmation
  chargeBack
  highRisk
  notPaid
  partiallyPaid
  pendding
  refunded
  successful
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  countryCode: StringFilter
  couponId: StringFilter
  createdAt: DateTimeFilter
  delivered: BoolFilter
  email: StringFilter
  exchangeRate: IntFilter
  gateway: StringFilter
  id: StringFilter
  ipAddress: StringFilter
  orderItems: OrderItemListRelationFilter
  productTitle: StringFilter
  referral: StringFilter
  riskLevel: IntFilter
  status: EnumOrderStatusFilter
  updatedAt: DateTimeFilter
  usdValue: IntFilter
  userAgent: StringFilter
}

input OrderWhereUniqueInput {
  id: String
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PermissionInput {
  object: String!
  operation: String!
}

type Plan {
  _count: PlanCount!
  createdAt: DateTime!
  duration: Duration!
  id: ID!
  name: String!
  price: Float!
  subscriptions: [Sub!]
  updatedAt: DateTime!
}

type PlanConnection {
  nodes: [Plan!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PlanCount {
  subscriptions: Int!
}

input PlanCreateInput {
  createdAt: DateTime
  duration: Duration!
  id: String
  name: String!
  price: Float!
  subscriptions: SubCreateNestedManyWithoutPlanInput
  updatedAt: DateTime
}

input PlanCreateNestedOneWithoutSubscriptionsInput {
  connect: PlanWhereUniqueInput
  connectOrCreate: PlanCreateOrConnectWithoutSubscriptionsInput
  create: PlanCreateWithoutSubscriptionsInput
}

input PlanCreateOrConnectWithoutSubscriptionsInput {
  create: PlanCreateWithoutSubscriptionsInput!
  where: PlanWhereUniqueInput!
}

input PlanCreateWithoutSubscriptionsInput {
  createdAt: DateTime
  duration: Duration!
  id: String
  name: String!
  price: Float!
  updatedAt: DateTime
}

input PlanOrderByWithRelationInput {
  createdAt: SortOrder
  duration: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  subscriptions: SubOrderByRelationAggregateInput
  updatedAt: SortOrder
}

enum PlanScalarFieldEnum {
  createdAt
  duration
  id
  name
  price
  updatedAt
}

input PlanUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: EnumDurationFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  subscriptions: SubUpdateManyWithoutPlanNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PlanUpdateOneRequiredWithoutSubscriptionsNestedInput {
  connect: PlanWhereUniqueInput
  connectOrCreate: PlanCreateOrConnectWithoutSubscriptionsInput
  create: PlanCreateWithoutSubscriptionsInput
  update: PlanUpdateWithoutSubscriptionsInput
  upsert: PlanUpsertWithoutSubscriptionsInput
}

input PlanUpdateWithoutSubscriptionsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  duration: EnumDurationFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PlanUpsertWithoutSubscriptionsInput {
  create: PlanCreateWithoutSubscriptionsInput!
  update: PlanUpdateWithoutSubscriptionsInput!
}

input PlanWhereInput {
  AND: [PlanWhereInput!]
  NOT: [PlanWhereInput!]
  OR: [PlanWhereInput!]
  createdAt: DateTimeFilter
  duration: EnumDurationFilter
  id: StringFilter
  name: StringFilter
  price: FloatFilter
  subscriptions: SubListRelationFilter
  updatedAt: DateTimeFilter
}

input PlanWhereUniqueInput {
  id: String
}

type Post {
  author: User
  authorId: String
  content: String
  createdAt: DateTime!
  id: ID!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
}

type PostConnection {
  nodes: [Post!]
  pageInfo: PageInfo!
  totalCount: Int!
}

input PostCreateManyAuthorInput {
  content: String
  createdAt: DateTime
  id: String
  published: Boolean!
  title: String!
  updatedAt: DateTime
}

input PostCreateManyAuthorInputEnvelope {
  data: [PostCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input PostCreateNestedManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
}

input PostCreateOrConnectWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutAuthorInput {
  content: String
  createdAt: DateTime
  id: String
  published: Boolean!
  title: String!
  updatedAt: DateTime
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostOrderByWithRelationInput {
  author: UserOrderByWithRelationInput
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

enum PostScalarFieldEnum {
  authorId
  content
  createdAt
  id
  published
  title
  updatedAt
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  authorId: StringNullableFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input PostUpdateManyMutationInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateManyWithWhereWithoutAuthorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithoutAuthorNestedInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithoutAuthorInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  author: UserWhereInput
  authorId: StringNullableFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input PostWhereUniqueInput {
  id: String
}

type Product {
  _count: ProductCount!
  categories: [ProductCategory!]
  createdAt: DateTime!
  cryptoConfirmations: Int!
  currency: String!
  description: String!
  dynamicUrl: String!
  id: ID!
  info: String!
  maxRiskLevel: Int!
  maximumQuantity: Int!
  minimumQuantity: Int!
  private: Boolean!
  productType: String!
  seller_note: String!
  stock: Int!
  stockAmount: Int!
  stockDelimiter: String!
  title: String!
  unlisted: Boolean!
  updatedAt: DateTime!
  vpn_block: Boolean!
  webhookUrl: String!
}

type ProductCategory {
  category: Category!
  categoryId: String!
  product: Product!
  productId: String!
}

input ProductCategoryCreateManyCategoryInput {
  productId: String!
}

input ProductCategoryCreateManyCategoryInputEnvelope {
  data: [ProductCategoryCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input ProductCategoryCreateManyProductInput {
  categoryId: String!
}

input ProductCategoryCreateManyProductInputEnvelope {
  data: [ProductCategoryCreateManyProductInput!]!
  skipDuplicates: Boolean
}

input ProductCategoryCreateNestedManyWithoutCategoryInput {
  connect: [ProductCategoryWhereUniqueInput!]
  connectOrCreate: [ProductCategoryCreateOrConnectWithoutCategoryInput!]
  create: [ProductCategoryCreateWithoutCategoryInput!]
  createMany: ProductCategoryCreateManyCategoryInputEnvelope
}

input ProductCategoryCreateNestedManyWithoutProductInput {
  connect: [ProductCategoryWhereUniqueInput!]
  connectOrCreate: [ProductCategoryCreateOrConnectWithoutProductInput!]
  create: [ProductCategoryCreateWithoutProductInput!]
  createMany: ProductCategoryCreateManyProductInputEnvelope
}

input ProductCategoryCreateOrConnectWithoutCategoryInput {
  create: ProductCategoryCreateWithoutCategoryInput!
  where: ProductCategoryWhereUniqueInput!
}

input ProductCategoryCreateOrConnectWithoutProductInput {
  create: ProductCategoryCreateWithoutProductInput!
  where: ProductCategoryWhereUniqueInput!
}

input ProductCategoryCreateWithoutCategoryInput {
  product: ProductCreateNestedOneWithoutCategoriesInput!
}

input ProductCategoryCreateWithoutProductInput {
  category: CategoryCreateNestedOneWithoutProductsInput!
}

input ProductCategoryListRelationFilter {
  every: ProductCategoryWhereInput
  none: ProductCategoryWhereInput
  some: ProductCategoryWhereInput
}

input ProductCategoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProductCategoryProductIdCategoryIdCompoundUniqueInput {
  categoryId: String!
  productId: String!
}

input ProductCategoryScalarWhereInput {
  AND: [ProductCategoryScalarWhereInput!]
  NOT: [ProductCategoryScalarWhereInput!]
  OR: [ProductCategoryScalarWhereInput!]
  categoryId: StringFilter
  productId: StringFilter
}

input ProductCategoryUncheckedUpdateManyWithoutCategoriesInput {
  categoryId: StringFieldUpdateOperationsInput
}

input ProductCategoryUncheckedUpdateManyWithoutProductsInput {
  productId: StringFieldUpdateOperationsInput
}

input ProductCategoryUpdateManyWithWhereWithoutCategoryInput {
  data: ProductCategoryUncheckedUpdateManyWithoutProductsInput!
  where: ProductCategoryScalarWhereInput!
}

input ProductCategoryUpdateManyWithWhereWithoutProductInput {
  data: ProductCategoryUncheckedUpdateManyWithoutCategoriesInput!
  where: ProductCategoryScalarWhereInput!
}

input ProductCategoryUpdateManyWithoutCategoryNestedInput {
  connect: [ProductCategoryWhereUniqueInput!]
  connectOrCreate: [ProductCategoryCreateOrConnectWithoutCategoryInput!]
  create: [ProductCategoryCreateWithoutCategoryInput!]
  createMany: ProductCategoryCreateManyCategoryInputEnvelope
  delete: [ProductCategoryWhereUniqueInput!]
  deleteMany: [ProductCategoryScalarWhereInput!]
  disconnect: [ProductCategoryWhereUniqueInput!]
  set: [ProductCategoryWhereUniqueInput!]
  update: [ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [ProductCategoryUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput!]
}

input ProductCategoryUpdateManyWithoutProductNestedInput {
  connect: [ProductCategoryWhereUniqueInput!]
  connectOrCreate: [ProductCategoryCreateOrConnectWithoutProductInput!]
  create: [ProductCategoryCreateWithoutProductInput!]
  createMany: ProductCategoryCreateManyProductInputEnvelope
  delete: [ProductCategoryWhereUniqueInput!]
  deleteMany: [ProductCategoryScalarWhereInput!]
  disconnect: [ProductCategoryWhereUniqueInput!]
  set: [ProductCategoryWhereUniqueInput!]
  update: [ProductCategoryUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [ProductCategoryUpdateManyWithWhereWithoutProductInput!]
  upsert: [ProductCategoryUpsertWithWhereUniqueWithoutProductInput!]
}

input ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput {
  data: ProductCategoryUpdateWithoutCategoryInput!
  where: ProductCategoryWhereUniqueInput!
}

input ProductCategoryUpdateWithWhereUniqueWithoutProductInput {
  data: ProductCategoryUpdateWithoutProductInput!
  where: ProductCategoryWhereUniqueInput!
}

input ProductCategoryUpdateWithoutCategoryInput {
  product: ProductUpdateOneRequiredWithoutCategoriesNestedInput
}

input ProductCategoryUpdateWithoutProductInput {
  category: CategoryUpdateOneRequiredWithoutProductsNestedInput
}

input ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput {
  create: ProductCategoryCreateWithoutCategoryInput!
  update: ProductCategoryUpdateWithoutCategoryInput!
  where: ProductCategoryWhereUniqueInput!
}

input ProductCategoryUpsertWithWhereUniqueWithoutProductInput {
  create: ProductCategoryCreateWithoutProductInput!
  update: ProductCategoryUpdateWithoutProductInput!
  where: ProductCategoryWhereUniqueInput!
}

input ProductCategoryWhereInput {
  AND: [ProductCategoryWhereInput!]
  NOT: [ProductCategoryWhereInput!]
  OR: [ProductCategoryWhereInput!]
  category: CategoryWhereInput
  categoryId: StringFilter
  product: ProductWhereInput
  productId: StringFilter
}

input ProductCategoryWhereUniqueInput {
  productId_categoryId: ProductCategoryProductIdCategoryIdCompoundUniqueInput
}

type ProductConnection {
  nodes: [Product!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductCount {
  categories: Int!
}

input ProductCreateInput {
  categories: ProductCategoryCreateNestedManyWithoutProductInput
  createdAt: DateTime
  cryptoConfirmations: Int!
  currency: String!
  description: String!
  dynamicUrl: String!
  id: String
  info: String!
  maxRiskLevel: Int!
  maximumQuantity: Int!
  minimumQuantity: Int!
  private: Boolean!
  productType: String!
  seller_note: String!
  stock: Int!
  stockAmount: Int!
  stockDelimiter: String!
  title: String!
  unlisted: Boolean!
  updatedAt: DateTime
  vpn_block: Boolean!
  webhookUrl: String!
}

input ProductCreateNestedOneWithoutCategoriesInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutCategoriesInput
  create: ProductCreateWithoutCategoriesInput
}

input ProductCreateOrConnectWithoutCategoriesInput {
  create: ProductCreateWithoutCategoriesInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutCategoriesInput {
  createdAt: DateTime
  cryptoConfirmations: Int!
  currency: String!
  description: String!
  dynamicUrl: String!
  id: String
  info: String!
  maxRiskLevel: Int!
  maximumQuantity: Int!
  minimumQuantity: Int!
  private: Boolean!
  productType: String!
  seller_note: String!
  stock: Int!
  stockAmount: Int!
  stockDelimiter: String!
  title: String!
  unlisted: Boolean!
  updatedAt: DateTime
  vpn_block: Boolean!
  webhookUrl: String!
}

input ProductOrderByWithRelationInput {
  categories: ProductCategoryOrderByRelationAggregateInput
  createdAt: SortOrder
  cryptoConfirmations: SortOrder
  currency: SortOrder
  description: SortOrder
  dynamicUrl: SortOrder
  id: SortOrder
  info: SortOrder
  maxRiskLevel: SortOrder
  maximumQuantity: SortOrder
  minimumQuantity: SortOrder
  private: SortOrder
  productType: SortOrder
  seller_note: SortOrder
  stock: SortOrder
  stockAmount: SortOrder
  stockDelimiter: SortOrder
  title: SortOrder
  unlisted: SortOrder
  updatedAt: SortOrder
  vpn_block: SortOrder
  webhookUrl: SortOrder
}

enum ProductScalarFieldEnum {
  createdAt
  cryptoConfirmations
  currency
  description
  dynamicUrl
  id
  info
  maxRiskLevel
  maximumQuantity
  minimumQuantity
  private
  productType
  seller_note
  stock
  stockAmount
  stockDelimiter
  title
  unlisted
  updatedAt
  vpn_block
  webhookUrl
}

input ProductUpdateInput {
  categories: ProductCategoryUpdateManyWithoutProductNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  cryptoConfirmations: IntFieldUpdateOperationsInput
  currency: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  dynamicUrl: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  info: StringFieldUpdateOperationsInput
  maxRiskLevel: IntFieldUpdateOperationsInput
  maximumQuantity: IntFieldUpdateOperationsInput
  minimumQuantity: IntFieldUpdateOperationsInput
  private: BoolFieldUpdateOperationsInput
  productType: StringFieldUpdateOperationsInput
  seller_note: StringFieldUpdateOperationsInput
  stock: IntFieldUpdateOperationsInput
  stockAmount: IntFieldUpdateOperationsInput
  stockDelimiter: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  unlisted: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  vpn_block: BoolFieldUpdateOperationsInput
  webhookUrl: StringFieldUpdateOperationsInput
}

input ProductUpdateOneRequiredWithoutCategoriesNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutCategoriesInput
  create: ProductCreateWithoutCategoriesInput
  update: ProductUpdateWithoutCategoriesInput
  upsert: ProductUpsertWithoutCategoriesInput
}

input ProductUpdateWithoutCategoriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  cryptoConfirmations: IntFieldUpdateOperationsInput
  currency: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  dynamicUrl: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  info: StringFieldUpdateOperationsInput
  maxRiskLevel: IntFieldUpdateOperationsInput
  maximumQuantity: IntFieldUpdateOperationsInput
  minimumQuantity: IntFieldUpdateOperationsInput
  private: BoolFieldUpdateOperationsInput
  productType: StringFieldUpdateOperationsInput
  seller_note: StringFieldUpdateOperationsInput
  stock: IntFieldUpdateOperationsInput
  stockAmount: IntFieldUpdateOperationsInput
  stockDelimiter: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  unlisted: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  vpn_block: BoolFieldUpdateOperationsInput
  webhookUrl: StringFieldUpdateOperationsInput
}

input ProductUpsertWithoutCategoriesInput {
  create: ProductCreateWithoutCategoriesInput!
  update: ProductUpdateWithoutCategoriesInput!
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  categories: ProductCategoryListRelationFilter
  createdAt: DateTimeFilter
  cryptoConfirmations: IntFilter
  currency: StringFilter
  description: StringFilter
  dynamicUrl: StringFilter
  id: StringFilter
  info: StringFilter
  maxRiskLevel: IntFilter
  maximumQuantity: IntFilter
  minimumQuantity: IntFilter
  private: BoolFilter
  productType: StringFilter
  seller_note: StringFilter
  stock: IntFilter
  stockAmount: IntFilter
  stockDelimiter: StringFilter
  title: StringFilter
  unlisted: BoolFilter
  updatedAt: DateTimeFilter
  vpn_block: BoolFilter
  webhookUrl: StringFilter
}

input ProductWhereUniqueInput {
  id: String
}

type Query {
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): CategoryConnection!
  category(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category!
  deleteOneProduct(where: ProductWhereUniqueInput!): Product!
  getRolePermissions(rolename: String!): [[String!]!]!
  getUserPermissions(username: String!): [[String!]!]!
  getUserRoles(username: String!): [String!]!
  license(cursor: LicenseWhereUniqueInput, distinct: [LicenseScalarFieldEnum!], orderBy: [LicenseOrderByWithRelationInput!], skip: Int, take: Int, where: LicenseWhereInput): License!
  licenses(cursor: LicenseWhereUniqueInput, distinct: [LicenseScalarFieldEnum!], orderBy: [LicenseOrderByWithRelationInput!], skip: Int, take: Int, where: LicenseWhereInput): LicenseConnection!
  me: User!
  orders(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): OrderConnection!
  plan(where: PlanWhereUniqueInput!): Plan!
  plans(cursor: PlanWhereUniqueInput, distinct: [PlanScalarFieldEnum!], orderBy: [PlanOrderByWithRelationInput!], skip: Int, take: Int, where: PlanWhereInput): PlanConnection!
  post(postId: String!): Post!
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): PostConnection!
  product(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product!
  products(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): ProductConnection!
  role(where: RoleWhereUniqueInput!): Role!
  roles(cursor: RoleWhereUniqueInput, distinct: [RoleScalarFieldEnum!], orderBy: [RoleOrderByWithRelationInput!], skip: Int, take: Int, where: RoleWhereInput): RoleConnection!
  sub(where: SubWhereUniqueInput!): Sub!
  subHistories(cursor: SubHistoryWhereUniqueInput, distinct: [SubHistoryScalarFieldEnum!], orderBy: [SubHistoryOrderByWithRelationInput!], skip: Int, take: Int, where: SubHistoryWhereInput): SubHistoryConnection!
  subHistory(where: SubHistoryWhereUniqueInput!): SubHistory!
  subs(cursor: SubWhereUniqueInput, distinct: [SubScalarFieldEnum!], orderBy: [SubOrderByWithRelationInput!], skip: Int, take: Int, where: SubWhereInput): SubConnection!
  updateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  userPosts(userId: String!): [Post!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): UserConnection!
}

enum QueryMode {
  default
  insensitive
}

type Role {
  createdAt: DateTime!
  description: String!
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type RoleConnection {
  nodes: [Role!]
  pageInfo: PageInfo!
  totalCount: Int!
}

input RoleCreateInput {
  createdAt: DateTime
  description: String!
  id: String
  name: String!
  updatedAt: DateTime
}

input RoleOrderByWithRelationInput {
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

enum RoleScalarFieldEnum {
  createdAt
  description
  id
  name
  updatedAt
}

input RoleUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input RoleWhereUniqueInput {
  id: String
  name: String
}

input SignupInput {
  firstname: String
  lastname: String
  password: String!
  username: String!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Sub {
  _count: SubCount!
  createdAt: DateTime!
  id: ID!
  plan: Plan!
  planId: String!
  status: SubscriptionStatus!
  subHistories: [SubHistory!]
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type SubConnection {
  nodes: [Sub!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SubCount {
  subHistories: Int!
}

input SubCreateInput {
  createdAt: DateTime
  id: String
  plan: PlanCreateNestedOneWithoutSubscriptionsInput!
  status: SubscriptionStatus!
  subHistories: SubHistoryCreateNestedManyWithoutSubInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutSubscriptionsInput!
}

input SubCreateManyPlanInput {
  createdAt: DateTime
  id: String
  status: SubscriptionStatus!
  updatedAt: DateTime
  userId: String!
}

input SubCreateManyPlanInputEnvelope {
  data: [SubCreateManyPlanInput!]!
  skipDuplicates: Boolean
}

input SubCreateNestedManyWithoutPlanInput {
  connect: [SubWhereUniqueInput!]
  connectOrCreate: [SubCreateOrConnectWithoutPlanInput!]
  create: [SubCreateWithoutPlanInput!]
  createMany: SubCreateManyPlanInputEnvelope
}

input SubCreateNestedOneWithoutSubHistoriesInput {
  connect: SubWhereUniqueInput
  connectOrCreate: SubCreateOrConnectWithoutSubHistoriesInput
  create: SubCreateWithoutSubHistoriesInput
}

input SubCreateOrConnectWithoutPlanInput {
  create: SubCreateWithoutPlanInput!
  where: SubWhereUniqueInput!
}

input SubCreateOrConnectWithoutSubHistoriesInput {
  create: SubCreateWithoutSubHistoriesInput!
  where: SubWhereUniqueInput!
}

input SubCreateWithoutPlanInput {
  createdAt: DateTime
  id: String
  status: SubscriptionStatus!
  subHistories: SubHistoryCreateNestedManyWithoutSubInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutSubscriptionsInput!
}

input SubCreateWithoutSubHistoriesInput {
  createdAt: DateTime
  id: String
  plan: PlanCreateNestedOneWithoutSubscriptionsInput!
  status: SubscriptionStatus!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutSubscriptionsInput!
}

type SubHistory {
  createdAt: DateTime!
  expiredAt: DateTime!
  id: ID!
  startAt: DateTime!
  sub: Sub!
  subId: String!
  updatedAt: DateTime!
}

type SubHistoryConnection {
  nodes: [SubHistory!]
  pageInfo: PageInfo!
  totalCount: Int!
}

input SubHistoryCreateInput {
  createdAt: DateTime
  expiredAt: DateTime!
  id: String
  startAt: DateTime!
  sub: SubCreateNestedOneWithoutSubHistoriesInput!
  updatedAt: DateTime
}

input SubHistoryCreateManySubInput {
  createdAt: DateTime
  expiredAt: DateTime!
  id: String
  startAt: DateTime!
  updatedAt: DateTime
}

input SubHistoryCreateManySubInputEnvelope {
  data: [SubHistoryCreateManySubInput!]!
  skipDuplicates: Boolean
}

input SubHistoryCreateNestedManyWithoutSubInput {
  connect: [SubHistoryWhereUniqueInput!]
  connectOrCreate: [SubHistoryCreateOrConnectWithoutSubInput!]
  create: [SubHistoryCreateWithoutSubInput!]
  createMany: SubHistoryCreateManySubInputEnvelope
}

input SubHistoryCreateOrConnectWithoutSubInput {
  create: SubHistoryCreateWithoutSubInput!
  where: SubHistoryWhereUniqueInput!
}

input SubHistoryCreateWithoutSubInput {
  createdAt: DateTime
  expiredAt: DateTime!
  id: String
  startAt: DateTime!
  updatedAt: DateTime
}

input SubHistoryListRelationFilter {
  every: SubHistoryWhereInput
  none: SubHistoryWhereInput
  some: SubHistoryWhereInput
}

input SubHistoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input SubHistoryOrderByWithRelationInput {
  createdAt: SortOrder
  expiredAt: SortOrder
  id: SortOrder
  startAt: SortOrder
  sub: SubOrderByWithRelationInput
  subId: SortOrder
  updatedAt: SortOrder
}

enum SubHistoryScalarFieldEnum {
  createdAt
  expiredAt
  id
  startAt
  subId
  updatedAt
}

input SubHistoryScalarWhereInput {
  AND: [SubHistoryScalarWhereInput!]
  NOT: [SubHistoryScalarWhereInput!]
  OR: [SubHistoryScalarWhereInput!]
  createdAt: DateTimeFilter
  expiredAt: DateTimeFilter
  id: StringFilter
  startAt: DateTimeFilter
  subId: StringFilter
  updatedAt: DateTimeFilter
}

input SubHistoryUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expiredAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  startAt: DateTimeFieldUpdateOperationsInput
  sub: SubUpdateOneRequiredWithoutSubHistoriesNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubHistoryUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expiredAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  startAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubHistoryUpdateManyWithWhereWithoutSubInput {
  data: SubHistoryUpdateManyMutationInput!
  where: SubHistoryScalarWhereInput!
}

input SubHistoryUpdateManyWithoutSubNestedInput {
  connect: [SubHistoryWhereUniqueInput!]
  connectOrCreate: [SubHistoryCreateOrConnectWithoutSubInput!]
  create: [SubHistoryCreateWithoutSubInput!]
  createMany: SubHistoryCreateManySubInputEnvelope
  delete: [SubHistoryWhereUniqueInput!]
  deleteMany: [SubHistoryScalarWhereInput!]
  disconnect: [SubHistoryWhereUniqueInput!]
  set: [SubHistoryWhereUniqueInput!]
  update: [SubHistoryUpdateWithWhereUniqueWithoutSubInput!]
  updateMany: [SubHistoryUpdateManyWithWhereWithoutSubInput!]
  upsert: [SubHistoryUpsertWithWhereUniqueWithoutSubInput!]
}

input SubHistoryUpdateWithWhereUniqueWithoutSubInput {
  data: SubHistoryUpdateWithoutSubInput!
  where: SubHistoryWhereUniqueInput!
}

input SubHistoryUpdateWithoutSubInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expiredAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  startAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubHistoryUpsertWithWhereUniqueWithoutSubInput {
  create: SubHistoryCreateWithoutSubInput!
  update: SubHistoryUpdateWithoutSubInput!
  where: SubHistoryWhereUniqueInput!
}

input SubHistoryWhereInput {
  AND: [SubHistoryWhereInput!]
  NOT: [SubHistoryWhereInput!]
  OR: [SubHistoryWhereInput!]
  createdAt: DateTimeFilter
  expiredAt: DateTimeFilter
  id: StringFilter
  startAt: DateTimeFilter
  sub: SubWhereInput
  subId: StringFilter
  updatedAt: DateTimeFilter
}

input SubHistoryWhereUniqueInput {
  id: String
}

input SubListRelationFilter {
  every: SubWhereInput
  none: SubWhereInput
  some: SubWhereInput
}

input SubOrderByRelationAggregateInput {
  _count: SortOrder
}

input SubOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  plan: PlanOrderByWithRelationInput
  planId: SortOrder
  status: SortOrder
  subHistories: SubHistoryOrderByRelationAggregateInput
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum SubScalarFieldEnum {
  createdAt
  id
  planId
  status
  updatedAt
  userId
}

input SubScalarWhereInput {
  AND: [SubScalarWhereInput!]
  NOT: [SubScalarWhereInput!]
  OR: [SubScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  planId: StringFilter
  status: EnumSubscriptionStatusFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input SubUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  plan: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  status: EnumSubscriptionStatusFieldUpdateOperationsInput
  subHistories: SubHistoryUpdateManyWithoutSubNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
}

input SubUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: EnumSubscriptionStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubUpdateManyWithWhereWithoutPlanInput {
  data: SubUpdateManyMutationInput!
  where: SubScalarWhereInput!
}

input SubUpdateManyWithoutPlanNestedInput {
  connect: [SubWhereUniqueInput!]
  connectOrCreate: [SubCreateOrConnectWithoutPlanInput!]
  create: [SubCreateWithoutPlanInput!]
  createMany: SubCreateManyPlanInputEnvelope
  delete: [SubWhereUniqueInput!]
  deleteMany: [SubScalarWhereInput!]
  disconnect: [SubWhereUniqueInput!]
  set: [SubWhereUniqueInput!]
  update: [SubUpdateWithWhereUniqueWithoutPlanInput!]
  updateMany: [SubUpdateManyWithWhereWithoutPlanInput!]
  upsert: [SubUpsertWithWhereUniqueWithoutPlanInput!]
}

input SubUpdateOneRequiredWithoutSubHistoriesNestedInput {
  connect: SubWhereUniqueInput
  connectOrCreate: SubCreateOrConnectWithoutSubHistoriesInput
  create: SubCreateWithoutSubHistoriesInput
  update: SubUpdateWithoutSubHistoriesInput
  upsert: SubUpsertWithoutSubHistoriesInput
}

input SubUpdateWithWhereUniqueWithoutPlanInput {
  data: SubUpdateWithoutPlanInput!
  where: SubWhereUniqueInput!
}

input SubUpdateWithoutPlanInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  status: EnumSubscriptionStatusFieldUpdateOperationsInput
  subHistories: SubHistoryUpdateManyWithoutSubNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
}

input SubUpdateWithoutSubHistoriesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  plan: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  status: EnumSubscriptionStatusFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
}

input SubUpsertWithWhereUniqueWithoutPlanInput {
  create: SubCreateWithoutPlanInput!
  update: SubUpdateWithoutPlanInput!
  where: SubWhereUniqueInput!
}

input SubUpsertWithoutSubHistoriesInput {
  create: SubCreateWithoutSubHistoriesInput!
  update: SubUpdateWithoutSubHistoriesInput!
}

input SubWhereInput {
  AND: [SubWhereInput!]
  NOT: [SubWhereInput!]
  OR: [SubWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  plan: PlanWhereInput
  planId: StringFilter
  status: EnumSubscriptionStatusFilter
  subHistories: SubHistoryListRelationFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input SubWhereUniqueInput {
  id: String
  userId: String
}

type Subscription {
  postCreated: Post!
}

enum SubscriptionStatus {
  Stop
  Subscribe
}

type Token {
  """JWT access token"""
  accessToken: JWT!

  """JWT refresh token"""
  refreshToken: JWT!
}

input UpdateUserInput {
  firstName: String
  lastName: String
}

type User {
  _count: UserCount!
  accountLicense: AccountLicense
  createdAt: DateTime!
  firstname: String
  id: ID!
  lastname: String
  password: String!
  posts: [Post!]
  subscriptions: [Sub!]
  updatedAt: DateTime!
  username: String!
}

type UserConnection {
  nodes: [User!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserCount {
  posts: Int!
  subscriptions: Int!
}

input UserCreateNestedOneWithoutSubscriptionsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSubscriptionsInput
  create: UserCreateWithoutSubscriptionsInput
}

input UserCreateOrConnectWithoutSubscriptionsInput {
  create: UserCreateWithoutSubscriptionsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutSubscriptionsInput {
  accountLicense: AccountLicenseCreateNestedOneWithoutUserInput
  createdAt: DateTime
  firstname: String
  id: String
  lastname: String
  password: String!
  posts: PostCreateNestedManyWithoutAuthorInput
  updatedAt: DateTime
  username: String!
}

input UserOrderByWithRelationInput {
  accountLicense: AccountLicenseOrderByWithRelationInput
  createdAt: SortOrder
  firstname: SortOrder
  id: SortOrder
  lastname: SortOrder
  password: SortOrder
  posts: PostOrderByRelationAggregateInput
  subscriptions: SubOrderByRelationAggregateInput
  updatedAt: SortOrder
  username: SortOrder
}

enum UserScalarFieldEnum {
  createdAt
  firstname
  id
  lastname
  password
  updatedAt
  username
}

input UserUpdateOneRequiredWithoutSubscriptionsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSubscriptionsInput
  create: UserCreateWithoutSubscriptionsInput
  update: UserUpdateWithoutSubscriptionsInput
  upsert: UserUpsertWithoutSubscriptionsInput
}

input UserUpdateWithoutSubscriptionsInput {
  accountLicense: AccountLicenseUpdateOneWithoutUserNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstname: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastname: NullableStringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutSubscriptionsInput {
  create: UserCreateWithoutSubscriptionsInput!
  update: UserUpdateWithoutSubscriptionsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accountLicense: AccountLicenseWhereInput
  createdAt: DateTimeFilter
  firstname: StringNullableFilter
  id: StringFilter
  lastname: StringNullableFilter
  password: StringFilter
  posts: PostListRelationFilter
  subscriptions: SubListRelationFilter
  updatedAt: DateTimeFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  id: String
  username: String
}
